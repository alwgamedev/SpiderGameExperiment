#pragma kernel RecalculateAntiClusterCoefficient;
#pragma kernel ComputePredictedPositions
#pragma kernel CountParticles
#pragma kernel SetCellStarts
#pragma kernel SortParticlesByCell
#pragma kernel CalculateDensity
#pragma kernel CalculateLambda
#pragma kernel CalculatePositionDelta
#pragma kernel AddPositionDelta
#pragma kernel StoreSolvedVelocity
#pragma kernel CalculateVorticityConfinementForce
#pragma kernel IntegrateParticles
#pragma kernel HandleWallCollisions
#pragma kernel ScrollNoise
#pragma kernel UpdateDensityTexture

#include "../SPH/SPHFunctions.hlsl"

static const int NUM_THREADS_PER_GROUP = 256;


//CONFIGURATION

const uint width;
const uint height;
const uint numCells;
const uint numParticles;


//SIM SETTINGS

uniform int kernelDeg;
uniform int densityKernelDeg;
uniform float dt;
uniform float dtInverse;
uniform float cellSize;
uniform float worldWidth;
uniform float worldHeight;
uniform float smoothingRadius;
uniform float smoothingRadiusSqrd;
uniform float2 gravity;
uniform float antiClusterK;
uniform float antiClusterDQ;
uniform int antiClusterN;
uniform float epsilon;
uniform float restDensity;
uniform float vorticityConfinement;
uniform float viscosity;
uniform float collisionBounciness;
uniform float obstacleRepulsion;
uniform uint numObstacles = 1;

float antiClusterCoefficient;


//SIM DATA

RWStructuredBuffer<float2> velocity;
RWStructuredBuffer<float2> position;
RWStructuredBuffer<float2> lastPosition;//stores initial position before pressure solving (during which position is really predicted position)
RWStructuredBuffer<float2> particleBuffer;//temp storage for deltaPosition and viscosity/vorticity confinement forces
RWStructuredBuffer<float> density;
RWStructuredBuffer<float> lambda;

//particle sorting
RWStructuredBuffer<uint> cellContainingParticle;
RWStructuredBuffer<uint> particlesByCell;
RWStructuredBuffer<uint> cellStart;
RWStructuredBuffer<uint> cellParticleCount;

StructuredBuffer<float4> obstacleData;


//DENSITY TEXTURE

uniform uint texWidth;
uniform uint texHeight;
uniform float texelSizeX;//world width of texel = worldWidth / texWidth
uniform float texelSizeY;
uniform float timeBlur;
uniform float densityTexSmoothingRadius;
uniform float densityTexSmoothingRadiusSqrd;
uniform float noiseSmoothingRadius;
uniform float noiseSmoothingRadiusSqrd;
uniform float noiseVelocityRadius;
uniform float noiseVelocityRadiusSqrd;
uniform float noiseScrollRate;
uniform float2 noiseStretch;
uniform float noiseTimeBlur;
uniform float noiseVelocityInfluence;
uniform float noiseVelocityInfluenceMax;

RWStructuredBuffer<float2> noise;
RWTexture2D<half2> densityTex;

#define Index(i, j) i * width + j

void SearchCellFloat(RWStructuredBuffer<float> particleData, float2 pos, uint cell, float r2, int kernelDeg, inout float sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += particleData[q] / density[q] * Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

//2do: let's make this work for any readius (so may need to sample more than 9 cells)
float SampleFloat(RWStructuredBuffer<float> particleData, float2 pos, uint cell, float r, float r2, int kernelDeg)
{
    int iMin = (int) clamp((pos.y - r) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + r) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - r) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + r) / cellSize, 0, width - 1);
    
    float sum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellFloat(particleData, pos, Index(i, j), r2, kernelDeg, sum);
        }
    } 
    return sum;
}

void SearchCellFloat2(RWStructuredBuffer<float2> particleData, float2 pos, uint cell, float r2, int kernelDeg, inout float2 sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += particleData[q] / density[q] * Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

//2do: let's make this work for any readius (so may need to sample more than 9 cells)
float2 SampleFloat2(RWStructuredBuffer<float2> particleData, float2 pos, uint cell, float r, float r2, int kernelDeg)
{
    int iMin = (int) clamp((pos.y - r) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + r) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - r) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + r) / cellSize, 0, width - 1);
    
    float2 sum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellFloat2(particleData, pos, Index(i, j), r2, kernelDeg, sum);
        }
    }
    return sum;
}

[numthreads(1, 1, 1)]
void RecalculateAntiClusterCoefficient()
{
    antiClusterCoefficient = -antiClusterK / WholePow(Poly2NKernel(kernelDeg, smoothingRadiusSqrd, antiClusterDQ * antiClusterDQ), antiClusterN);
} 

void RepelFromObstacles(uint p)
{
    for (uint k = 0; k < numObstacles; k++)
    {
        float4 o = obstacleData[k];
        float2 localPos = float2((position[p].x - o.x) / o.z, (position[p].y - o.y) / o.z);
        float s2 = localPos.x * localPos.x + localPos.y * localPos.y;
        if (s2 < 1)
        {
            float sInverse = rsqrt(s2);
            float2 dir = isnan(sInverse) || isinf(sInverse) ? float2(0, 1) : sInverse * localPos;
            velocity[p] += dt * (1 - s2) * (o.w * obstacleRepulsion - dot(velocity[p], dir)) * dir;
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ComputePredictedPositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        lastPosition[id.x] = position[id.x];
        velocity[id.x] += dt * gravity;
        position[id.x] += dt * velocity[id.x];//this is the predicted position, to feed into pressure solver
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CountParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float w = position[id.x].x / cellSize;
        float h = position[id.x].y / cellSize;
        uint i = (uint) clamp(h, 0, height - 1);
        uint j = (uint) clamp(w, 0, width - 1);
        uint c = Index(i, j);
        cellContainingParticle[id.x] = c;
        InterlockedAdd(cellParticleCount[c], 1);
    }
}

//not parallelized
[numthreads(1, 1, 1)]
void SetCellStarts(uint3 id : SV_DispatchThreadID)
{
    cellStart[0] = 0;
    for (uint k = 1; k < numCells + 1; k++)
    {
        cellStart[k] = cellStart[k - 1] + cellParticleCount[k - 1];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SortParticlesByCell(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint d;
        InterlockedAdd(cellParticleCount[c], -1, d);
        uint k = cellStart[c] + d - 1;
        particlesByCell[k] = id.x;
    }
}

void SearchCellForDensity(float2 pos, uint cell, float r2, int kernelDeg, inout float sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        density[id.x] = SampleFloat(density, position[id.x], cellContainingParticle[id.x], smoothingRadius, smoothingRadiusSqrd, densityKernelDeg);
    }
}

void SearchCellForLambdaDenom(uint p, uint cell, inout float2 selfSum, inout float neighborSum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//o/w grad is zero
        {
            float2 d = position[p] - position[q];
            half d2 = dot(d, d);
            if (d2 < smoothingRadiusSqrd)
            {
                float2 grad = Poly2NKernelGradient(densityKernelDeg, smoothingRadiusSqrd, d2, d);
                selfSum += grad;
                neighborSum += dot(grad, grad);
            }
        }
    }
}

float LambdaDenom(uint p, uint cell)
{
    float2 pos = position[p];
    int iMin = (int) clamp((pos.y - smoothingRadius) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + smoothingRadius) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - smoothingRadius) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + smoothingRadius) / cellSize, 0, width - 1);
    
    float2 selfSum = 0;
    float neighborSum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellForLambdaDenom(p, Index(i, j), selfSum, neighborSum);
        }
    }
    
    return epsilon + dot(selfSum, selfSum) + neighborSum;
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateLambda(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint cell = cellContainingParticle[id.x];
        lambda[id.x] = (restDensity - density[id.x]) / LambdaDenom(id.x, cell);
    }
}

float AntiClusterTerm(float d2)
{
    return antiClusterCoefficient * WholePow(Poly2NKernel(kernelDeg, smoothingRadiusSqrd, d2), antiClusterN);
}

void SearchCellForPositionDelta(uint p, uint cell, inout float2 sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//otherwise gradient is zero
        {
            float2 d = position[p] - position[q];
            half d2 = dot(d, d);
            if (d2 < smoothingRadiusSqrd)
            {
                sum += (lambda[p] + lambda[q] + AntiClusterTerm(d2)) * Poly2NKernelGradient(kernelDeg, smoothingRadiusSqrd, d2, d);
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculatePositionDelta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float2 pos = position[id.x];
        int iMin = (int) clamp((pos.y - smoothingRadius) / cellSize, 0, height - 1);
        int iMax = (int) clamp((pos.y + smoothingRadius) / cellSize, 0, height - 1);
        int jMin = (int) clamp((pos.x - smoothingRadius) / cellSize, 0, width - 1);
        int jMax = (int) clamp((pos.x + smoothingRadius) / cellSize, 0, width - 1);
    
        float2 sum = 0;
        for (int i = iMin; i < iMax + 1; i++)
        {
            for (int j = jMin; j < jMax + 1; j++)
            {
                SearchCellForPositionDelta(id.x, Index(i, j), sum);
            }
        }
    
        particleBuffer[id.x] = 1 / restDensity * sum;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void AddPositionDelta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        position[id.x] += particleBuffer[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void StoreSolvedVelocity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        velocity[id.x] = dtInverse * (position[id.x] - lastPosition[id.x]);
    }
}

void SearchCellForVorticityConfinement(uint p, uint cell, inout float2 viscSum, inout float2 vortSum)
{
    float rInverse = 1 / smoothingRadius;
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//otherwise contribution is zero
        {
            float2 positionDiff = position[p] - position[q];
            float d2 = dot(positionDiff, positionDiff);
            if (d2 < smoothingRadiusSqrd)
            {
                float d = sqrt(d2);
                viscSum += (smoothingRadius - d) * (velocity[q] - velocity[p]);//let's sample some viscosity while we're here
                
                float dInverse = 1 / d;
                float d3Inverse = dInverse / d2;
                
                if (!isnan(d3Inverse) && !isinf(d3Inverse))
                {
                    float2 velocityDiff = velocity[p] - velocity[q];
                    
                    float f = dInverse * rInverse * (velocityDiff.x * positionDiff.y - velocityDiff.y * positionDiff.x);
                    float fx = rInverse * (-positionDiff.x * d3Inverse * f - dInverse * velocityDiff.y);
                    float fy = rInverse * (-positionDiff.y * d3Inverse * f + dInverse * velocityDiff.x);
                    float2 F = abs(f) * normalize(float2(fy, -fx));
                    if (!isnan(F.x) && !isinf(F.x) && !isnan(F.y) && !isinf(F.y))
                    {
                        vortSum += F;
                    }
                    //using linear kernel A(1 - d / r)
                }
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateVorticityConfinementForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float2 pos = position[id.x];
        int iMin = (int) clamp((pos.y - smoothingRadius) / cellSize, 0, height - 1);
        int iMax = (int) clamp((pos.y + smoothingRadius) / cellSize, 0, height - 1);
        int jMin = (int) clamp((pos.x - smoothingRadius) / cellSize, 0, width - 1);
        int jMax = (int) clamp((pos.x + smoothingRadius) / cellSize, 0, width - 1);
    
        float2 viscSum = 0;
        float2 vortSum = 0;
        for (int i = iMin; i < iMax + 1; i++)
        {
            for (int j = jMin; j < jMax + 1; j++)
            {
                SearchCellForVorticityConfinement(id.x, Index(i, j), viscSum, vortSum);
            }
        }
        
        particleBuffer[id.x] = viscosity * viscSum - vorticityConfinement / density[id.x] * vortSum;
    }
}


[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void IntegrateParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        velocity[id.x] += dt * particleBuffer[id.x];//add viscosity and vorticity confinement forces
        RepelFromObstacles(id.x);
        position[id.x] = lastPosition[id.x] + dt * velocity[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void HandleWallCollisions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        if (position[id.x].x < cellSize)
        {
            float dx = position[id.x].x - cellSize;
            position[id.x].x -= dx;
            if (velocity[id.x].x < 0)
            {
                velocity[id.x].x = -collisionBounciness * velocity[id.x].x;
            //velocity[id.x].y = collisionBounciness * velocity[id.x].y;
            }
            velocity[id.x].x -= dx / dt;
        }
        else if (position[id.x].x > worldWidth - cellSize)
        {
            float dx = position[id.x].x - worldWidth + cellSize;
            position[id.x].x -= dx;
            if (velocity[id.x].x > 0)
            {
                velocity[id.x].x = -collisionBounciness * velocity[id.x].x;
            //velocity[id.x].y = collisionBounciness * velocity[id.x].y;
            }
            velocity[id.x].x -= dx / dt;
        }

        if (position[id.x].y < cellSize)
        {
            float dy = position[id.x].y - cellSize;
            position[id.x].y -= dy;
            if (velocity[id.x].y < 0)
            {
            //velocity[id.x].x = collisionBounciness * velocity[id.x].x;
                velocity[id.x].y = -collisionBounciness * velocity[id.x].y;
            }
            velocity[id.x].y -= dy / dt;
        }
        else if (position[id.x].y > worldHeight - cellSize)
        {
            float dy = position[id.x].y - worldHeight + cellSize;
            position[id.x].y -= dy;
            if (velocity[id.x].y > 0)
            {
            //velocity[id.x].x = collisionBounciness * velocity[id.x].x;
                velocity[id.x].y = -collisionBounciness * velocity[id.x].y;
            }
            velocity[id.x].y -= dy / dt;
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ScrollNoise(uint3 id : SV_DispatchThreadID)
{
    if (id.x  < numParticles)
    {
        noise[id.x].x += noise[id.x].y * noiseScrollRate * dt;
        if (noise[id.x].x > 1 || noise[id.x].x < 0)
        {
            noise[id.x].y *= -1;
        }
    }
}

void SearchCellForNoise(float2 pos, float2 v, float2 w, float s, uint cell, float r2, inout float noiseSum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float2 a = dot(d, v);
        float2 b = dot(d, w);
        d = (a * s / noiseStretch.x) * v + (b * s / noiseStretch.y) * w;//stretch the noise wrt velocity!
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            noiseSum += noise[q].x / density[q] * Poly2NKernel(densityKernelDeg, r2, d2);
        }
    }
}

//2do: for the density texture, we should just do one search (tracking two sums along the way - density & noise)
float SampleNoise(float2 pos, uint cell, uint i, uint j, float r, float r2)
{
    int iMin = (int) clamp((pos.y - smoothingRadius) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + smoothingRadius) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - smoothingRadius) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + smoothingRadius) / cellSize, 0, width - 1);
    
    float2 v = SampleFloat2(velocity, pos, cell, noiseVelocityRadius, noiseVelocityRadiusSqrd, kernelDeg);
    float v2 = dot(v, v);
    float s = 1 / v2;
    if (isnan(s) || isinf(s))
    {
        return 0;
    }
    float2 w = float2(-v.y, v.x);
    float nSum = 0;
    
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellForNoise(pos, v, w, s, Index(i, j), r2, nSum);
        }
    }
    
    return (1 + min(noiseVelocityInfluence * nSum * nSum * v2, noiseVelocityInfluenceMax)) * nSum;
}

[numthreads(16, 16, 1)]
void UpdateDensityTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x < texWidth && id.y < texHeight)
    {
        //position of texel center on grid (world units)
        float x = texelSizeX * (id.x + 0.5);
        float y = texelSizeY * (id.y + 0.5);
        
        uint i = (uint) clamp(y / cellSize, 0, height - 1);
        uint j = (uint) clamp(x / cellSize, 0, width - 1);
        
        uint2 k = uint2(id.x, id.y);
        densityTex[k] = half2(lerp(densityTex[k].x, SampleFloat(density, float2(x, y), Index(i, j), densityTexSmoothingRadius, densityTexSmoothingRadiusSqrd, densityKernelDeg), timeBlur),
            lerp(densityTex[k].y, SampleNoise(float2(x, y), Index(i, j), i, j, noiseSmoothingRadius, noiseSmoothingRadiusSqrd), noiseTimeBlur));
    }
}