#pragma kernel RecalculateAntiClusterCoefficient;
#pragma kernel ComputePredictedPositions
#pragma kernel CountParticles
#pragma kernel SetCellStarts
#pragma kernel SortParticlesByCell
#pragma kernel CalculateDensity
#pragma kernel CalculateLambda
#pragma kernel CalculatePositionDelta
#pragma kernel AddPositionDelta
#pragma kernel StoreSolvedVelocity
#pragma kernel CalculateVorticityConfinementForce
#pragma kernel IntegrateParticles
#pragma kernel HandleWallCollisions
#pragma kernel UpdateDensityTexture

#include "../SPH/SPHFunctions.hlsl"

static const int NUM_THREADS_PER_GROUP = 256;


//CONFIGURATION

const uint width;
const uint height;
const uint numCells;
const uint numParticles;


//SIM SETTINGS

uniform int kernelDeg;
uniform int densityKernelDeg;
uniform float dt;
uniform float dtInverse;
uniform float cellSize;
uniform float worldWidth;
uniform float worldHeight;
uniform float smoothingRadius;
uniform float smoothingRadiusSqrd;
uniform float2 gravity;
uniform float antiClusterK;
uniform float antiClusterDQ;
uniform int antiClusterN;
uniform float epsilon;
uniform float restDensity;
uniform float vorticityConfinement;
uniform float viscosity;
uniform float collisionBounciness;
uniform float obstacleRepulsion;
uniform uint numObstacles = 1;

float antiClusterCoefficient;


//SIM DATA

RWStructuredBuffer<float2> velocity;
RWStructuredBuffer<float2> position;
RWStructuredBuffer<float2> lastPosition;//stores initial position before pressure solving (during which position is really predicted position)
RWStructuredBuffer<float2> particleBuffer;//for deltaPosition and vorticity confinement force
RWStructuredBuffer<float> density;
RWStructuredBuffer<float> lambda;

//particle sorting
RWStructuredBuffer<uint> cellContainingParticle;
RWStructuredBuffer<uint> particlesByCell;
RWStructuredBuffer<uint> cellStart;
RWStructuredBuffer<uint> cellParticleCount;

StructuredBuffer<float4> obstacleData;

//RENDERING

uniform uint texWidth;
uniform uint texHeight;
uniform float texelSizeX; //=worldWidth / texWidth
uniform float texelSizeY;
uniform float timeBlur;
uniform float densityTexSmoothingRadius;
uniform float densityTexSmoothingRadiusSqrd;

RWStructuredBuffer<float> noise;
RWTexture2D<half2> densityTex;

#define Index(i, j) i * width + j

[numthreads(1, 1, 1)]
void RecalculateAntiClusterCoefficient()
{
    antiClusterCoefficient = -antiClusterK / WholePow(Poly2NKernel(kernelDeg, smoothingRadiusSqrd, antiClusterDQ * antiClusterDQ), antiClusterN);
} 

void RepelFromObstacles(uint p)
{
    for (uint k = 0; k < numObstacles; k++)
    {
        float4 o = obstacleData[k];
        float2 localPos = float2((position[p].x - o.x) / o.z, (position[p].y - o.y) / o.z);
        float s2 = localPos.x * localPos.x + localPos.y * localPos.y;
        if (s2 < 1)
        {
            float sInverse = rsqrt(s2);
            float2 dir = isnan(sInverse) || isinf(sInverse) ? float2(0, 1) : sInverse * localPos;
            velocity[p] += dt * (1 - s2) * (o.w * obstacleRepulsion - dot(velocity[p], dir)) * dir;
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ComputePredictedPositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        lastPosition[id.x] = position[id.x];
        velocity[id.x] += dt * gravity;
        position[id.x] += dt * velocity[id.x];//this is the predicted position, to feed into pressure solver
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CountParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float w = position[id.x].x / cellSize;
        float h = position[id.x].y / cellSize;
        uint i = (uint) clamp(h, 0, height - 1);
        uint j = (uint) clamp(w, 0, width - 1);
        uint c = Index(i, j);
        cellContainingParticle[id.x] = c;
        InterlockedAdd(cellParticleCount[c], 1);
    }
}

//not parallelized
[numthreads(1, 1, 1)]
void SetCellStarts(uint3 id : SV_DispatchThreadID)
{
    cellStart[0] = 0;
    for (uint k = 1; k < numCells + 1; k++)
    {
        cellStart[k] = cellStart[k - 1] + cellParticleCount[k - 1];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SortParticlesByCell(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint d;
        InterlockedAdd(cellParticleCount[c], -1, d);
        uint k = cellStart[c] + d - 1;
        particlesByCell[k] = id.x;
    }
}

void SearchCellForDensity(float2 pos, uint cell, float r2, int kernelDeg, inout float sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

//yes I'm really passing all these bc if called for a particle position we don't need to calculate the cell
//but if called for an arbitrary position we do -- so the cell data should be calculated in whatever way is best before this method is called
float SampleDensity(float2 pos, uint cell, uint i, uint j, float r, float r2, int kernelDeg)
{
    float cellX = clamp(pos.x - j * cellSize, 0, cellSize);
    float cellY = clamp(pos.y - i * cellSize, 0, cellSize);
    float max = cellSize - r;
    
    float sum = 0;
        
    //search middle row
    SearchCellForDensity(pos, cell, r2, kernelDeg, sum);
        
    if (j > 0 && cellX < r)
    {
        SearchCellForDensity(pos, cell - 1, r2, kernelDeg, sum);
    }
    if (j < width - 1 && cellX > max)
    {
        SearchCellForDensity(pos, cell + 1, r2, kernelDeg, sum);
    }
        
    //search upper row
    if (i < height - 1 && cellY > max)
    {
        SearchCellForDensity(pos, cell + width, r2, kernelDeg, sum);
            
        if (j > 0 && cellX < r)
        {
            SearchCellForDensity(pos, cell + width - 1, r2, kernelDeg, sum);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForDensity(pos, cell + width + 1, r2, kernelDeg, sum);
        }
    }
        
        //search bottom row
    if (i > 0 && cellY < r)
    {
        SearchCellForDensity(pos, cell - width, r2, kernelDeg, sum);
            
        if (j > 0 && cellX < r)
        {
            SearchCellForDensity(pos, cell - width - 1, r2, kernelDeg, sum);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForDensity(pos, cell - width + 1, r2, kernelDeg, sum);
        }
    }
        
    return sum;
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint i = c / width;
        uint j = c % width;
        
        density[id.x] = SampleDensity(position[id.x], c, i, j, smoothingRadius, smoothingRadiusSqrd, densityKernelDeg);
    }
}

void SearchCellForLambdaDenom(uint p, uint cell, inout float2 selfSum, inout float neighborSum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//o/w grad is zero
        {
            float2 d = position[p] - position[q];
            half d2 = dot(d, d);
            if (d2 < smoothingRadiusSqrd)
            {
                float2 grad = Poly2NKernelGradient(densityKernelDeg, smoothingRadiusSqrd, d2, d);
                selfSum += grad;
                neighborSum += dot(grad, grad);
            }
        }
    }
}

float LambdaDenom(uint p, uint cell)
{
    uint i = cell / width;
    uint j = cell % width;
    float cellX = clamp(position[p].x - j * cellSize, 0, cellSize);
    float cellY = clamp(position[p].y - i * cellSize, 0, cellSize);
    float max = cellSize - smoothingRadius;
    
    float2 selfSum = 0;
    float neighborSum = 0;
    
    //search middle row
    SearchCellForLambdaDenom(p, cell, selfSum, neighborSum);
        
    if (j > 0 && cellX < smoothingRadius)
    {
        SearchCellForLambdaDenom(p, cell - 1, selfSum, neighborSum);
    }
    if (j < width - 1 && cellX > max)
    {
        SearchCellForLambdaDenom(p, cell + 1, selfSum, neighborSum);
    }
        
    //search upper row
    if (i < height - 1 && cellY > max)
    {
        SearchCellForLambdaDenom(p, cell + width, selfSum, neighborSum);
            
        if (j > 0 && cellX < smoothingRadius)
        {
            SearchCellForLambdaDenom(p, cell + width - 1, selfSum, neighborSum);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForLambdaDenom(p, cell + width + 1, selfSum, neighborSum);
        }
    }
        
    //search bottom row
    if (i > 0 && cellY < smoothingRadius)
    {
        SearchCellForLambdaDenom(p, cell - width, selfSum, neighborSum);
            
        if (j > 0 && cellX < smoothingRadius)
        {
            SearchCellForLambdaDenom(p, cell - width - 1, selfSum, neighborSum);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForLambdaDenom(p, cell - width + 1, selfSum, neighborSum);
        }
    }
    
    return epsilon + dot(selfSum, selfSum) + neighborSum;
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateLambda(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint cell = cellContainingParticle[id.x];
        lambda[id.x] = (restDensity - density[id.x]) / LambdaDenom(id.x, cell);
    }
}

float AntiClusterTerm(float d2)
{
    return antiClusterCoefficient * WholePow(Poly2NKernel(kernelDeg, smoothingRadiusSqrd, d2), antiClusterN);
}

//recommended to use (gradient of) spiky kernel instead
void SearchCellForPositionDelta(uint p, uint cell, inout float2 sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//otherwise gradient is zero
        {
            float2 d = position[p] - position[q];
            half d2 = dot(d, d);
            if (d2 < smoothingRadiusSqrd)
            {
                sum += (lambda[p] + lambda[q] + AntiClusterTerm(d2)) * Poly2NKernelGradient(kernelDeg, smoothingRadiusSqrd, d2, d);
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculatePositionDelta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint cell = cellContainingParticle[id.x];
        uint i = cell / width;
        uint j = cell % width;
        float cellX = clamp(position[id.x].x - j * cellSize, 0, cellSize);
        float cellY = clamp(position[id.x].y - i * cellSize, 0, cellSize);
        float max = cellSize - smoothingRadius;
    
        float2 sum = 0;
    
        //search middle row
        SearchCellForPositionDelta(id.x, cell, sum);
        
        if (j > 0 && cellX < smoothingRadius)
        {
            SearchCellForPositionDelta(id.x, cell - 1, sum);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForPositionDelta(id.x, cell + 1, sum);
        }
        
        //search upper row
        if (i < height - 1 && cellY > max)
        {
            SearchCellForPositionDelta(id.x, cell + width, sum);
            
            if (j > 0 && cellX < smoothingRadius)
            {
                SearchCellForPositionDelta(id.x, cell + width - 1, sum);
            }
            if (j < width - 1 && cellX > max)
            {
                SearchCellForPositionDelta(id.x, cell + width + 1, sum);
            }
        }
        
        //search bottom row
        if (i > 0 && cellY < smoothingRadius)
        {
            SearchCellForPositionDelta(id.x, cell - width, sum);
            
            if (j > 0 && cellX < smoothingRadius)
            {
                SearchCellForPositionDelta(id.x, cell - width - 1, sum);
            }
            if (j < width - 1 && cellX > max)
            {
                SearchCellForPositionDelta(id.x, cell - width + 1, sum);
            }
        }
        
        particleBuffer[id.x] = 1 / restDensity * sum;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void AddPositionDelta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        position[id.x] += particleBuffer[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void StoreSolvedVelocity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        velocity[id.x] = dtInverse * (position[id.x] - lastPosition[id.x]);
    }
}

void SearchCellForVorticityConfinement(uint p, uint cell, inout float2 sum)
{
    float rInverse = 1 / smoothingRadius;
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//otherwise contribution is zero
        {
            float2 positionDiff = position[p] - position[q];
            float d2 = dot(positionDiff, positionDiff);
            if (d2 < smoothingRadiusSqrd)
            {
                float dInverse = rsqrt(d2);
                float d3Inverse = dInverse / d2;
                
                if (!isnan(d3Inverse) && !isinf(d3Inverse))
                {
                    float2 velocityDiff = velocity[p] - velocity[q];
                    
                    float f = dInverse * rInverse * (velocityDiff.x * positionDiff.y - velocityDiff.y * positionDiff.x);
                    float fx = rInverse * (-positionDiff.x * d3Inverse * f - dInverse * velocityDiff.y);
                    float fy = rInverse * (-positionDiff.y * d3Inverse * f + dInverse * velocityDiff.x);
                    float2 F = abs(f) * normalize(float2(fy, -fx));
                    if (!isnan(F.x) && !isinf(F.x) && !isnan(F.y) && !isinf(F.y))
                    {
                        sum += F;
                    }
                    //using linear kernel A(1 - d / r)
                }
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateVorticityConfinementForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint cell = cellContainingParticle[id.x];
        uint i = cell / width;
        uint j = cell % width;
        float cellX = clamp(position[id.x].x - j * cellSize, 0, cellSize);
        float cellY = clamp(position[id.x].y - i * cellSize, 0, cellSize);
        float max = cellSize - smoothingRadius;
    
        float2 sum = 0;
    
        //search middle row
        SearchCellForVorticityConfinement(id.x, cell, sum);
        
        if (j > 0 && cellX < smoothingRadius)
        {
            SearchCellForVorticityConfinement(id.x, cell - 1, sum);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForVorticityConfinement(id.x, cell + 1, sum);
        }
        
        //search upper row
        if (i < height - 1 && cellY > max)
        {
            SearchCellForVorticityConfinement(id.x, cell + width, sum);
            
            if (j > 0 && cellX < smoothingRadius)
            {
                SearchCellForVorticityConfinement(id.x, cell + width - 1, sum);
            }
            if (j < width - 1 && cellX > max)
            {
                SearchCellForVorticityConfinement(id.x, cell + width + 1, sum);
            }
        }
        
        //search bottom row
        if (i > 0 && cellY < smoothingRadius)
        {
            SearchCellForVorticityConfinement(id.x, cell - width, sum);
            
            if (j > 0 && cellX < smoothingRadius)
            {
                SearchCellForVorticityConfinement(id.x, cell - width - 1, sum);
            }
            if (j < width - 1 && cellX > max)
            {
                SearchCellForVorticityConfinement(id.x, cell - width + 1, sum);
            }
        }
        
        particleBuffer[id.x] = -vorticityConfinement / density[id.x] * sum;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void IntegrateParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        velocity[id.x] += dt * particleBuffer[id.x];//add vorticity confinement force
        RepelFromObstacles(id.x);
        position[id.x] = lastPosition[id.x] + dt * velocity[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void HandleWallCollisions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        if (position[id.x].x < cellSize)
        {
            float dx = position[id.x].x - cellSize;
            position[id.x].x -= dx;
            if (velocity[id.x].x < 0)
            {
                velocity[id.x].x = -collisionBounciness * velocity[id.x].x;
            //velocity[id.x].y = collisionBounciness * velocity[id.x].y;
            }
            velocity[id.x].x -= dx / dt;
        }
        else if (position[id.x].x > worldWidth - cellSize)
        {
            float dx = position[id.x].x - worldWidth + cellSize;
            position[id.x].x -= dx;
            if (velocity[id.x].x > 0)
            {
                velocity[id.x].x = -collisionBounciness * velocity[id.x].x;
            //velocity[id.x].y = collisionBounciness * velocity[id.x].y;
            }
            velocity[id.x].x -= dx / dt;
        }

        if (position[id.x].y < cellSize)
        {
            float dy = position[id.x].y - cellSize;
            position[id.x].y -= dy;
            if (velocity[id.x].y < 0)
            {
            //velocity[id.x].x = collisionBounciness * velocity[id.x].x;
                velocity[id.x].y = -collisionBounciness * velocity[id.x].y;
            }
            velocity[id.x].y -= dy / dt;
        }
        else if (position[id.x].y > worldHeight - cellSize)
        {
            float dy = position[id.x].y - worldHeight + cellSize;
            position[id.x].y -= dy;
            if (velocity[id.x].y > 0)
            {
            //velocity[id.x].x = collisionBounciness * velocity[id.x].x;
                velocity[id.x].y = -collisionBounciness * velocity[id.x].y;
            }
            velocity[id.x].y -= dy / dt;
        }
    }
}

void SearchCellForNoise(float2 pos, uint cell, float r2, int kernelDeg, inout float sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += noise[q] / density[q] * Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

//2do: for the density texture, we should just do one search (tracking two sums along the way - density & noise)
float SampleNoise(float2 pos, uint cell, uint i, uint j, float r, float r2, int kernelDeg)
{
    float cellX = clamp(pos.x - j * cellSize, 0, cellSize);
    float cellY = clamp(pos.y - i * cellSize, 0, cellSize);
    float max = cellSize - r;
    
    float sum = 0;
        
    //search middle row
    SearchCellForNoise(pos, cell, r2, kernelDeg, sum);
        
    if (j > 0 && cellX < r)
    {
        SearchCellForNoise(pos, cell - 1, r2, kernelDeg, sum);
    }
    if (j < width - 1 && cellX > max)
    {
        SearchCellForNoise(pos, cell + 1, r2, kernelDeg, sum);
    }
        
    //search upper row
    if (i < height - 1 && cellY > max)
    {
        SearchCellForNoise(pos, cell + width, r2, kernelDeg, sum);
            
        if (j > 0 && cellX < r)
        {
            SearchCellForNoise(pos, cell + width - 1, r2, kernelDeg, sum);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForNoise(pos, cell + width + 1, r2, kernelDeg, sum);
        }
    }
        
    //search bottom row
    if (i > 0 && cellY < r)
    {
        SearchCellForNoise(pos, cell - width, r2, kernelDeg, sum);
            
        if (j > 0 && cellX < r)
        {
            SearchCellForNoise(pos, cell - width - 1, r2, kernelDeg, sum);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForNoise(pos, cell - width + 1, r2, kernelDeg, sum);
        }
    }
        
    return sum;
}

[numthreads(16, 16, 1)]
void UpdateDensityTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x < texWidth && id.y < texHeight)
    {
        //position of texel center on grid (world units)
        float x = texelSizeX * (id.x + 0.5);
        float y = texelSizeY * (id.y + 0.5);
        
        uint i = (uint) clamp(y / cellSize, 0, height - 1);
        uint j = (uint) clamp(x / cellSize, 0, width - 1);
        
        uint2 k = uint2(id.x, id.y);
        densityTex[k] = half2(lerp(densityTex[k].x, SampleDensity(float2(x, y), Index(i, j), i, j, densityTexSmoothingRadius, densityTexSmoothingRadiusSqrd, densityKernelDeg), timeBlur),
            SampleNoise(float2(x, y), Index(i, j), i, j, densityTexSmoothingRadius, densityTexSmoothingRadiusSqrd, densityKernelDeg)); //can add radius and time blur to noise (maybe also translate over time)
    }
}