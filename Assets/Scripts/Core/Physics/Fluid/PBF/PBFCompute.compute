#pragma kernel RecalculateAntiClusterCoefficient
#pragma kernel ComputePredictedPositions
#pragma kernel CountParticles
#pragma kernel SetCellStarts
#pragma kernel SortParticlesByCell
#pragma kernel CalculateDensity
#pragma kernel CalculateLambda
#pragma kernel CalculatePositionDelta
#pragma kernel AddPositionDelta
#pragma kernel StoreSolvedVelocity
#pragma kernel CalculateVorticityConfinementForce
#pragma kernel IntegrateParticles
#pragma kernel HandleWallCollisions
#pragma kernel ScrollNoise
#pragma kernel UpdateDensityTexture
#pragma kernel SpawnFoam
#pragma kernel UpdateFoam
#pragma kernel TransferFoamSurvivorsToBuffer
#pragma kernel TransferFoamSurvivorsBack
#pragma kernel CompleteFoamUpdate

#include "../SPH/SPHFunctions.hlsl"

static const int NUM_THREADS_PER_GROUP = 256;


//CONFIGURATION

const uint width;
const uint height;
const uint numCells;
const uint numParticles;
const uint numFoamParticles;


//SIM SETTINGS

uniform int kernelDeg;
uniform float dt;
uniform float dtInverse;
uniform float cellSize;
uniform float worldWidth;
uniform float worldHeight;
uniform float smoothingRadius;
uniform float smoothingRadiusSqrd;
uniform float2 gravity;
uniform float antiClusterK;
uniform float antiClusterDQ;
uniform int antiClusterN;
uniform float epsilon;
uniform float restDensity;
uniform float vorticityConfinement;
uniform float viscosity;
uniform float collisionBounciness;
uniform float obstacleRepulsion;
uniform uint numObstacles = 1;

uniform float foamSpawnRate;
uniform float foamSpawnRadiusMultiplier;
uniform float foamSpawnRadiusMax;
uniform float foamLifetimeMin;
uniform float foamLifetimeMax;
uniform float bubbleThreshold;
uniform float foamThreshold;
uniform float bubbleBuoyancy;
uniform float bubbleDrag;

float antiClusterCoefficient;


//SIM DATA

RWStructuredBuffer<float2> velocity;
RWStructuredBuffer<float2> position;
RWStructuredBuffer<float2> lastPosition; //stores initial position before pressure solving (during which position is really predicted position)
RWStructuredBuffer<float2> particleBuffer; //temp storage for deltaPosition and viscosity/vorticity confinement forces
RWStructuredBuffer<float> density;
RWStructuredBuffer<float> lambda;

//particle sorting
RWStructuredBuffer<uint> cellContainingParticle;
RWStructuredBuffer<uint> particlesByCell;
RWStructuredBuffer<uint> cellStart;
RWStructuredBuffer<uint> cellParticleCount;

//obstacles
StructuredBuffer<float4> obstacleData;

//foam particles
struct FoamParticle//combining into struct bc we're running up against the per-kernel UAV limit (max 8 buffers bound to a kernel)
{
    float2 velocity;
    float2 position;
    float life;
};

RWStructuredBuffer<FoamParticle> foamParticle;
RWStructuredBuffer<FoamParticle> foamParticleBuffer;
RWStructuredBuffer<uint> foamParticleCounter;//[0] = num active, [1] = num surviving after update


//DENSITY TEXTURE

uniform uint texWidth;
uniform uint texHeight;
uniform float texelSizeX;//world width of texel = worldWidth / texWidth
uniform float texelSizeY;
uniform float timeBlur;

uniform float densityTexSmoothingRadius;
uniform float densityTexSmoothingRadiusSqrd;

uniform float noiseSmoothingRadius;
uniform float noiseSmoothingRadiusSqrd;
uniform float noiseVelocityRadius;
uniform float noiseVelocityRadiusSqrd;
uniform float noiseScrollRate;
uniform float2 noiseStretch;
uniform float noiseTimeBlur;
uniform float noiseVelocityInfluence;
uniform float noiseVelocityInfluenceMax;

uniform float foamSmoothingRadius;
uniform float foamSmoothingRadiusSqrd;
uniform float foamVelocityInfluence;
uniform float foamVelocityThreshold;

RWStructuredBuffer<float2> noise;
RWTexture2D<half4> densityTex;
//RWTexture2D<half2> velocityTex;

#define Index(i, j) i * width + j

void SearchCellFloat(RWStructuredBuffer<float> particleData, float2 pos, uint cell, float r2, int kernelDeg, inout float sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += particleData[q] / density[q] * Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

//2do: let's make this work for any readius (so may need to sample more than 9 cells)
float SampleFloat(RWStructuredBuffer<float> particleData, float2 pos, float r, float r2, int kernelDeg)
{
    int iMin = (int) clamp((pos.y - r) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + r) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - r) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + r) / cellSize, 0, width - 1);
    
    float sum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellFloat(particleData, pos, Index(i, j), r2, kernelDeg, sum);
        }
    }
    return sum;
}

void SearchCellFloat2(RWStructuredBuffer<float2> particleData, float2 pos, uint cell, float r2, int kernelDeg, inout float2 sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += particleData[q] / density[q] * Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

//2do: let's make this work for any readius (so may need to sample more than 9 cells)
float2 SampleFloat2(RWStructuredBuffer<float2> particleData, float2 pos, float r, float r2, int kernelDeg)
{
    int iMin = (int) clamp((pos.y - r) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + r) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - r) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + r) / cellSize, 0, width - 1);
    
    float2 sum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellFloat2(particleData, pos, Index(i, j), r2, kernelDeg, sum);
        }
    }
    return sum;
}

[numthreads(1, 1, 1)]
void RecalculateAntiClusterCoefficient()
{
    antiClusterCoefficient = -antiClusterK / WholePow(Poly2NKernel(kernelDeg, smoothingRadiusSqrd, antiClusterDQ * antiClusterDQ), antiClusterN);
}

void RepelFromObstacles(uint p)
{
    for (uint k = 0; k < numObstacles; k++)
    {
        float4 o = obstacleData[k];
        float2 localPos = float2((position[p].x - o.x) / o.z, (position[p].y - o.y) / o.z);
        float s2 = localPos.x * localPos.x + localPos.y * localPos.y;
        if (s2 < 1)
        {
            s2 = max(s2, 0.01);
            float sInverse = rsqrt(s2);
            //float2 dir = isnan(sInverse) || isinf(sInverse) ? float2(0, 1) : sInverse * localPos;
            float2 dir = sInverse * localPos;
            velocity[p] += dt * (1 - s2) * (o.w * obstacleRepulsion - dot(velocity[p], dir)) * dir;
        }
        }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ComputePredictedPositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        lastPosition[id.x] = position[id.x];
        velocity[id.x] += dt * gravity;
        position[id.x] += dt * velocity[id.x]; //this is the predicted position, to feed into pressure solver
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CountParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float w = position[id.x].x / cellSize;
        float h = position[id.x].y / cellSize;
        uint i = (uint) clamp(h, 0, height - 1);
        uint j = (uint) clamp(w, 0, width - 1);
        uint c = Index(i, j);
        cellContainingParticle[id.x] = c;
        InterlockedAdd(cellParticleCount[c], 1);
    }
}

//not parallelized
[numthreads(1, 1, 1)]
void SetCellStarts()
{
    cellStart[0] = 0;
    for (uint k = 1; k < numCells + 1; k++)
    {
        cellStart[k] = cellStart[k - 1] + cellParticleCount[k - 1];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SortParticlesByCell(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint d;
        InterlockedAdd(cellParticleCount[c], -1, d);
        uint k = cellStart[c] + d - 1;
        particlesByCell[k] = id.x;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        density[id.x] = SampleFloat(density, position[id.x], smoothingRadius, smoothingRadiusSqrd, kernelDeg);
    }
}

void SearchCellForLambdaDenom(uint p, uint cell, inout float2 selfSum, inout float neighborSum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//o/w grad is zero
        {
            float2 d = position[p] - position[q];
            half d2 = dot(d, d);
            if (d2 < smoothingRadiusSqrd)
            {
                float2 grad = Poly2NKernelGradient(kernelDeg, smoothingRadiusSqrd, d2, d);
                selfSum += grad;
                neighborSum += dot(grad, grad);
            }
        }
    }
}

float LambdaDenom(uint p)
{
    float2 pos = position[p];
    int iMin = (int) clamp((pos.y - smoothingRadius) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + smoothingRadius) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - smoothingRadius) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + smoothingRadius) / cellSize, 0, width - 1);
    
    float2 selfSum = 0;
    float neighborSum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellForLambdaDenom(p, Index(i, j), selfSum, neighborSum);
        }
    }
    
    return epsilon + dot(selfSum, selfSum) + neighborSum;
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateLambda(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint cell = cellContainingParticle[id.x];
        lambda[id.x] = (restDensity - density[id.x]) / LambdaDenom(id.x);
    }
}

float AntiClusterTerm(float d2)
{
    return antiClusterCoefficient * WholePow(Poly2NKernel(kernelDeg, smoothingRadiusSqrd, d2), antiClusterN);
}

void SearchCellForPositionDelta(uint p, uint cell, inout float2 sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//otherwise gradient is zero
        {
            float2 d = position[p] - position[q];
            half d2 = dot(d, d);
            if (d2 < smoothingRadiusSqrd)
            {
                sum += (lambda[p] + lambda[q] + AntiClusterTerm(d2)) * Poly2NKernelGradient(kernelDeg, smoothingRadiusSqrd, d2, d);
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculatePositionDelta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float2 pos = position[id.x];
        int iMin = (int) clamp((pos.y - smoothingRadius) / cellSize, 0, height - 1);
        int iMax = (int) clamp((pos.y + smoothingRadius) / cellSize, 0, height - 1);
        int jMin = (int) clamp((pos.x - smoothingRadius) / cellSize, 0, width - 1);
        int jMax = (int) clamp((pos.x + smoothingRadius) / cellSize, 0, width - 1);
    
        float2 sum = 0;
        for (int i = iMin; i < iMax + 1; i++)
        {
            for (int j = jMin; j < jMax + 1; j++)
            {
                SearchCellForPositionDelta(id.x, Index(i, j), sum);
            }
        }
    
        particleBuffer[id.x] = 1 / restDensity * sum;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void AddPositionDelta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        position[id.x] += particleBuffer[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void StoreSolvedVelocity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        velocity[id.x] = dtInverse * (position[id.x] - lastPosition[id.x]);
    }
}

void SearchCellForVorticityConfinement(uint p, uint cell, inout float2 viscSum, inout float2 vortSum)
{
    float rInverse = 1 / smoothingRadius;
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//otherwise contribution is zero
        {
            float2 positionDiff = position[p] - position[q];
            float d2 = dot(positionDiff, positionDiff);
            if (d2 < smoothingRadiusSqrd)
            {
                float d = sqrt(d2);
                viscSum += (smoothingRadius - d) * (velocity[q] - velocity[p]); //let's sample some viscosity while we're here
                
                float dInverse = 1 / d;
                float d3Inverse = dInverse / d2;
                
                if (!isnan(d3Inverse) && !isinf(d3Inverse))
                {
                    float2 velocityDiff = velocity[p] - velocity[q];
                    
                    float f = dInverse * rInverse * (velocityDiff.x * positionDiff.y - velocityDiff.y * positionDiff.x);
                    float fx = rInverse * (-positionDiff.x * d3Inverse * f - dInverse * velocityDiff.y);
                    float fy = rInverse * (-positionDiff.y * d3Inverse * f + dInverse * velocityDiff.x);
                    float2 F = abs(f) * normalize(float2(fy, -fx));
                    if (!isnan(F.x) && !isinf(F.x) && !isnan(F.y) && !isinf(F.y))
                    {
                        vortSum += F;
                    }
                    //using linear kernel A(1 - d / r)
                }
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateVorticityConfinementForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float2 pos = position[id.x];
        int iMin = (int) clamp((pos.y - smoothingRadius) / cellSize, 0, height - 1);
        int iMax = (int) clamp((pos.y + smoothingRadius) / cellSize, 0, height - 1);
        int jMin = (int) clamp((pos.x - smoothingRadius) / cellSize, 0, width - 1);
        int jMax = (int) clamp((pos.x + smoothingRadius) / cellSize, 0, width - 1);
    
        float2 viscSum = 0;
        float2 vortSum = 0;
        for (int i = iMin; i < iMax + 1; i++)
        {
            for (int j = jMin; j < jMax + 1; j++)
            {
                SearchCellForVorticityConfinement(id.x, Index(i, j), viscSum, vortSum);
            }
        }
        
        particleBuffer[id.x] = viscosity * viscSum - vorticityConfinement / density[id.x] * vortSum;
    }
}


[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void IntegrateParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        velocity[id.x] += dt * particleBuffer[id.x];//add viscosity and vorticity confinement forces
        RepelFromObstacles(id.x);
        position[id.x] = lastPosition[id.x] + dt * velocity[id.x];
    }
}

void HandleWallCollisions(inout float2 position, inout float2 velocity)
{
    if (position.x < cellSize)
    {
        float dx = position.x - cellSize;
        position.x -= dx;
        if (velocity.x < 0)
        {
            velocity.x = -collisionBounciness * velocity.x;
            //velocity.y = collisionBounciness * velocity.y;
        }
        velocity.x -= dx / dt;
    }
    else if (position.x > worldWidth - cellSize)
    {
        float dx = position.x - worldWidth + cellSize;
        position.x -= dx;
        if (velocity.x > 0)
        {
            velocity.x = -collisionBounciness * velocity.x;
            //velocity[id.x].y = collisionBounciness * velocity[id.x].y;
        }
        velocity.x -= dx / dt;
    }

    if (position.y < cellSize)
    {
        float dy = position.y - cellSize;
        position.y -= dy;
        if (velocity.y < 0)
        {
            //velocity.x = collisionBounciness * velocity.x;
            velocity.y = -collisionBounciness * velocity.y;
        }
        velocity.y -= dy / dt;
    }
    else if (position.y > worldHeight - cellSize)
    {
        float dy = position.y - worldHeight + cellSize;
        position.y -= dy;
        if (velocity.y > 0)
        {
            //velocity.x = collisionBounciness * velocity.x;
            velocity.y = -collisionBounciness * velocity.y;
        }
        velocity.y -= dy / dt;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void HandleWallCollisions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        HandleWallCollisions(position[id.x], velocity[id.x]);
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ScrollNoise(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        noise[id.x].x += noise[id.x].y * noiseScrollRate * dt;
        if (noise[id.x].x > 1 || noise[id.x].x < 0)
        {
            noise[id.x].y *= -1;
        }
    }
}

void SearchCellForNoise(float2 pos, float2 v, float2 w, float2 sv, float2 sw, uint cell, float r2, inout float noiseSum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float2 a = dot(d, sv);
        float2 b = dot(d, sw);
        d = (a / noiseStretch.x) * v + (b / noiseStretch.y) * w; //stretch the noise wrt velocity!
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            noiseSum += noise[q].x / density[q] * Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

float SampleNoise(float2 pos, float r, float r2, out float2 v)
{
    int iMin = (int) clamp((pos.y - r) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + r) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - r) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + r) / cellSize, 0, width - 1);
    
    v = SampleFloat2(velocity, pos, r, r2, kernelDeg);
    float v2 = dot(v, v);
    float s = 1 / v2;
    if (isnan(s) || isinf(s))
    {
        return 0;
    }
    float2 w = float2(-v.y, v.x);
    float2 sv = s * v;
    float2 sw = float2(-sv.y, sv.x);
    float nSum = 0;
    
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellForNoise(pos, v, w, sv, sw, Index(i, j), r2, nSum);
        }
    }
    
    return (1 + min(noiseVelocityInfluence * nSum * nSum * v2, noiseVelocityInfluenceMax)) * nSum;
}

//float2 SampleSurfaceNormal(float2 pos, float r, float r2)
//{
//    float2 n = SampleGradient(density, pos, r, r2, densityKernelDeg);
//    float l = dot(n, n);
//    return l > surfaceNormalThreshold ? -rsqrt(l) * n : 0;
//}

void SearchCellForFoaminess(float2 pos, float2 vel, uint cell, float r, float r2, inout float sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 posDiff = pos - position[q];
        float d2 = dot(posDiff, posDiff);
        if (d2 < r2)
        {
            
            float d = sqrt(d2);
            float dInverse = 1 / d;
            if (!isnan(dInverse) && !isinf(dInverse))
            {
                    
                float2 velDiff = vel - velocity[q];
                float s = sqrt(dot(velDiff, velDiff));
                sum.x += (s - dInverse * dot(velDiff, posDiff)) * SimpleLinearKernel(r, r2, d) / density[q];
            }
        }
    }
}

float SampleFoaminess(float2 pos, float2 vel, float densitySample, float r, float r2)
{
    float a = clamp(foamVelocityInfluence * dot(vel, vel) - foamVelocityThreshold, 0, 1);
    if (a == 0)
    {
        return 0;
    }
    
    int iMin = (int) clamp((pos.y - r) / cellSize, 0, height - 1);
    int iMax = (int) clamp((pos.y + r) / cellSize, 0, height - 1);
    int jMin = (int) clamp((pos.x - r) / cellSize, 0, width - 1);
    int jMax = (int) clamp((pos.x + r) / cellSize, 0, width - 1);
    
    float sum = 0;
    
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellForFoaminess(pos, vel, Index(i, j), r, r2, sum);
        }
    }
    
    return a * sum / (0.01 + densitySample);//divide by density an easy way to make foaminess stronger near the surface
}

[numthreads(16, 16, 1)]
void UpdateDensityTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x < texWidth && id.y < texHeight)
    {
        //position of texel center on grid (world units)
        float2 pos = float2(texelSizeX * (id.x + 0.5), texelSizeY * (id.y + 0.5));
        
        float2 vel;
        float densitySample = SampleFloat(density, pos, densityTexSmoothingRadius, densityTexSmoothingRadiusSqrd, kernelDeg);
        float noiseSample = SampleNoise(pos, noiseSmoothingRadius, noiseSmoothingRadiusSqrd, vel);
        float foaminess = SampleFoaminess(pos, vel, densitySample, foamSmoothingRadius, foamSmoothingRadiusSqrd);
        //^divide by density easy way of making foaminess stronger near surface (not doing wave crest detection bc i think it already looks great as is)
        
        uint2 k = uint2(id.x, id.y);
        densityTex[k] = half4(
            lerp(densityTex[k].x, densitySample, timeBlur),
            lerp(densityTex[k].y, noiseSample, noiseTimeBlur),
            lerp(densityTex[k].z, foaminess, timeBlur),
            0
        );
        //velocityTex[k] = vel;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SpawnFoam(uint3 id :SV_DispatchThreadID)
{
    if (id.x < numParticles && foamParticleCounter[0] < numFoamParticles)
    {
        float2 pos = position[id.x];
        uint2 k = uint2(
            (uint) clamp(pos.x / texelSizeX, 0, texWidth - 1),
            (uint) clamp(pos.y / texelSizeY, 0, texHeight - 1)
        );
        
        uint seed = asuint(69 * pos.x + 54321 * pos.y/* + 1234569 * foamTime*/);
        
        int numToSpawn = densityTex[k].x * densityTex[k].z * foamSpawnRate * dt;
        
        if (numToSpawn > 0)
        {
            float spawnRadius = min(densityTex[k].x * foamSpawnRadiusMultiplier, foamSpawnRadiusMax);
            
            float2 v = dt * velocity[id.x];
            float d = rsqrt(dot(v, v));
            if (isnan(d) || isinf(d))
            {
                return;
            }
            float2 w = foamSpawnRadiusMax * d * v;
            w = (-w.y, w.x);
            while (numToSpawn > 0)
            {
                uint index;
                InterlockedAdd(foamParticleCounter[0], 1, index);
                if (index < numFoamParticles)
                {
                    float a = RandomFloat01(seed);
                    float b = 2 * RandomFloat01(seed) - 1;
                    float2 c = b * w;
                    foamParticle[index].position = pos + a * v + c;
                    foamParticle[index].velocity = velocity[id.x] + c;
                    foamParticle[index].life = lerp(foamLifetimeMin, foamLifetimeMax, RandomFloat01(seed));
                    
                    numToSpawn--;
                }
                else
                {
                    break;
                }
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void UpdateFoam(uint3 id : SV_DispatchThreadID)
{
    if (id.x < foamParticleCounter[0])
    {
        foamParticle[id.x].life -= dt;
        if (foamParticle[id.x].life > 0)
        {
            float2 pos = foamParticle[id.x].position;
            uint2 k = uint2(
                (uint) clamp(pos.x / texelSizeX, 0, texWidth - 1),
                (uint) clamp(pos.y / texelSizeY, 0, texHeight - 1)
            );
            float density = densityTex[k].x;
        
            if (density > bubbleThreshold)//bubble particle
            {
                float2 v = SampleFloat2(velocity, pos, foamSmoothingRadius, foamSmoothingRadiusSqrd, kernelDeg);
                foamParticle[id.x].velocity += -dt * bubbleBuoyancy * gravity + bubbleDrag * (v - foamParticle[id.x].velocity);
            }
            else if (density > foamThreshold)//foam particle
            {
                foamParticle[id.x].velocity = SampleFloat2(velocity, pos, foamSmoothingRadius, foamSmoothingRadiusSqrd, kernelDeg);
            }
            else //spray particle
            {
                foamParticle[id.x].velocity += dt * gravity;
            }
        
            foamParticle[id.x].position += dt * foamParticle[id.x].velocity;
            HandleWallCollisions(foamParticle[id.x].position, foamParticle[id.x].velocity);
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void TransferFoamSurvivorsToBuffer(uint3 id : SV_DispatchThreadID)
{
    if (id.x < foamParticleCounter[0] && foamParticle[id.x].life > 0)
    {
        int index;
        InterlockedAdd(foamParticleCounter[1], 1, index);
        foamParticleBuffer[index] = foamParticle[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void TransferFoamSurvivorsBack(uint3 id : SV_DispatchThreadID)
{
    if (id.x < foamParticleCounter[1])
    {
        foamParticle[id.x] = foamParticleBuffer[id.x];
    }
}

[numthreads(1, 1, 1)]
void CompleteFoamUpdate()
{
    foamParticleCounter[0] = foamParticleCounter[1];
    foamParticleCounter[1] = 0;
}