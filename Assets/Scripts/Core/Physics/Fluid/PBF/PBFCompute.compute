#pragma kernel RecalculateAntiClusterCoefficient
#pragma kernel ComputePredictedPositions
#pragma kernel CountParticles
#pragma kernel SetCellStarts
#pragma kernel SortParticlesByCell
#pragma kernel CalculateDensity
#pragma kernel CalculateLambda
#pragma kernel CalculatePositionDelta
#pragma kernel AddPositionDelta
#pragma kernel StoreSolvedVelocity
#pragma kernel CalculateVorticityConfinementForce
#pragma kernel IntegrateParticles
#pragma kernel HandleWallCollisions
#pragma kernel ScrollNoise
#pragma kernel UpdateDensityTexture
#pragma kernel SpawnFoam
#pragma kernel UpdateFoam
#pragma kernel TransferFoamSurvivorsToBuffer
#pragma kernel TransferFoamSurvivorsBack
#pragma kernel CompleteFoamUpdate

#include "../SPH/SPHFunctions.hlsl"
#include "./PBFComputeSettings.hlsl"

static const int NUM_THREADS_PER_GROUP = 256;

StructuredBuffer<PBFConfig> configBuffer;//so the macro can have the short name
StructuredBuffer<PBFVariables> varsBuffer;
uniform uint numObstacles;

#define config configBuffer[0]
#define vars varsBuffer[0]

float antiClusterCoefficient;


//SIM DATA

RWStructuredBuffer<float2> velocity;
RWStructuredBuffer<float2> position;
RWStructuredBuffer<float2> lastPosition;//stores initial position before pressure solving (during which position is really predicted position)
RWStructuredBuffer<float2> particleBuffer;//temp storage for deltaPosition and viscosity/vorticity confinement forces
RWStructuredBuffer<float> density;
RWStructuredBuffer<float> lambda;
RWStructuredBuffer<float2> noise;

//particle sorting
RWStructuredBuffer<uint> cellContainingParticle;
RWStructuredBuffer<uint> particlesByCell;
RWStructuredBuffer<uint> cellStart;
RWStructuredBuffer<uint> cellParticleCount;

//obstacles
StructuredBuffer<float4> obstacleData;

//foam particles
struct FoamParticle//combining into struct bc we're running up against the per-kernel UAV limit (max 8 buffers bound to a kernel)
{
    float2 velocity;
    float2 position;
    float life;
    float colorNoise;
    float sizeNoise;
    float density;
};

RWStructuredBuffer<FoamParticle> foamParticle;
RWStructuredBuffer<FoamParticle> foamParticleBuffer;
RWStructuredBuffer<uint> foamParticleCounter;//[0] = num active, [1] = num surviving after update

//density texture
RWTexture2D<half4> densityTex;

#define Index(i, j) i * config.width + j

void SearchCellFloat(RWStructuredBuffer<float> particleData, float2 pos, uint cell, float r2, int kernelDeg, inout float sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += particleData[q] / density[q] * Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

//2do: let's make this work for any readius (so may need to sample more than 9 cells)
float SampleFloat(RWStructuredBuffer<float> particleData, float2 pos, float r, float r2, int kernelDeg)
{
    int iMin = (int) clamp((pos.y - r) / vars.cellSize, 0, config.height - 1);
    int iMax = (int) clamp((pos.y + r) / vars.cellSize, 0, config.height - 1);
    int jMin = (int) clamp((pos.x - r) / vars.cellSize, 0, config.width - 1);
    int jMax = (int) clamp((pos.x + r) / vars.cellSize, 0, config.width - 1);
    
    float sum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellFloat(particleData, pos, Index(i, j), r2, kernelDeg, sum);
        }
    }
    return sum;
}

void SearchCellFloat2(RWStructuredBuffer<float2> particleData, float2 pos, uint cell, float r2, int kernelDeg, inout float2 sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += particleData[q] / density[q] * Poly2NKernel(kernelDeg, r2, d2);
        }
    }
}

//2do: let's make this work for any readius (so may need to sample more than 9 cells)
float2 SampleFloat2(RWStructuredBuffer<float2> particleData, float2 pos, float r, float r2, int kernelDeg)
{
    int iMin = (int) clamp((pos.y - r) / vars.cellSize, 0, config.height - 1);
    int iMax = (int) clamp((pos.y + r) / vars.cellSize, 0, config.height - 1);
    int jMin = (int) clamp((pos.x - r) / vars.cellSize, 0, config.width - 1);
    int jMax = (int) clamp((pos.x + r) / vars.cellSize, 0, config.width - 1);
    
    float2 sum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellFloat2(particleData, pos, Index(i, j), r2, kernelDeg, sum);
        }
    }
    return sum;
}

void SearchCellGradient(RWStructuredBuffer<float> particleData, float2 pos, uint cell, float r2, int kernelDeg, inout float2 sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            sum += particleData[q] / density[q] * Poly2NKernelGradient(kernelDeg, r2, d2, d);
        }
    }
}

float2 SampleGradient(RWStructuredBuffer<float> particleData, float2 pos, float r, float r2, int kernelDeg)
{
    int iMin = (int) clamp((pos.y - r) / vars.cellSize, 0, config.height - 1);
    int iMax = (int) clamp((pos.y + r) / vars.cellSize, 0, config.height - 1);
    int jMin = (int) clamp((pos.x - r) / vars.cellSize, 0, config.width - 1);
    int jMax = (int) clamp((pos.x + r) / vars.cellSize, 0, config.width - 1);
    
    float2 sum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellGradient(particleData, pos, Index(i, j), r2, kernelDeg, sum);
        }
    }
    return sum;
}

float2 NonnormalizedSurfaceNormal(float2 pos, float r, float r2)
{
    return -SampleGradient(density, pos, r, r2, vars.kernelDeg);
}

float2 SurfaceNormal(float2 pos, float r, float r2)
{
    float2 n = NonnormalizedSurfaceNormal(pos, r, r2);
    float l = dot(n, n);
    return l > vars.surfaceNormalThreshold ? -rsqrt(l) * n : 0;
}

[numthreads(1, 1, 1)]
void RecalculateAntiClusterCoefficient()
{
    antiClusterCoefficient = -vars.antiClusterK / WholePow(Poly2NKernel(vars.kernelDeg, vars.smoothingRadiusSqrd, vars.antiClusterDQ * vars.antiClusterDQ), vars.antiClusterN);
}

void RepelFromObstacles(uint p)
{
    for (uint k = 0; k < numObstacles; k++)
    {
        float4 o = obstacleData[k];
        float2 localPos = float2((position[p].x - o.x) / o.z, (position[p].y - o.y) / o.z);
        float s2 = localPos.x * localPos.x + localPos.y * localPos.y;
        if (s2 < 1)
        {
            s2 = max(s2, 0.25);
            float sInverse = rsqrt(s2);
            float2 dir = sInverse * localPos;
            velocity[p] += vars.dt * (1 - s2) * (o.w * vars.obstacleRepulsion * dir - velocity[p]);
        }
        }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ComputePredictedPositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        lastPosition[id.x] = position[id.x];
        velocity[id.x] += vars.dt * vars.gravity;
        position[id.x] += vars.dt * velocity[id.x]; //this is the predicted position, to feed into pressure solver
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CountParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        float w = position[id.x].x / vars.cellSize;
        float h = position[id.x].y / vars.cellSize;
        uint i = (uint) clamp(h, 0, config.height - 1);
        uint j = (uint) clamp(w, 0, config.width - 1);
        uint c = Index(i, j);
        cellContainingParticle[id.x] = c;
        InterlockedAdd(cellParticleCount[c], 1);
    }
}

//not parallelized
[numthreads(1, 1, 1)]
void SetCellStarts()
{
    cellStart[0] = 0;
    for (uint k = 1; k < config.numCells + 1; k++)
    {
        cellStart[k] = cellStart[k - 1] + cellParticleCount[k - 1];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SortParticlesByCell(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint d;
        InterlockedAdd(cellParticleCount[c], -1, d);
        uint k = cellStart[c] + d - 1;
        particlesByCell[k] = id.x;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        density[id.x] = SampleFloat(density, position[id.x], vars.smoothingRadius, vars.smoothingRadiusSqrd, vars.kernelDeg);
    }
}

void SearchCellForLambdaDenom(uint p, uint cell, inout float2 selfSum, inout float neighborSum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//o/w grad is zero
        {
            float2 d = position[p] - position[q];
            half d2 = dot(d, d);
            if (d2 < vars.smoothingRadiusSqrd)
            {
                float2 grad = Poly2NKernelGradient(vars.kernelDeg, vars.smoothingRadiusSqrd, d2, d);
                selfSum += grad;
                neighborSum += dot(grad, grad);
            }
        }
    }
}

float LambdaDenom(uint p)
{
    float2 pos = position[p];
    int iMin = (int) clamp((pos.y - vars.smoothingRadius) / vars.cellSize, 0, config.height - 1);
    int iMax = (int) clamp((pos.y + vars.smoothingRadius) / vars.cellSize, 0, config.height - 1);
    int jMin = (int) clamp((pos.x - vars.smoothingRadius) / vars.cellSize, 0, config.width - 1);
    int jMax = (int) clamp((pos.x + vars.smoothingRadius) / vars.cellSize, 0, config.width - 1);
    
    float2 selfSum = 0;
    float neighborSum = 0;
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellForLambdaDenom(p, Index(i, j), selfSum, neighborSum);
        }
    }
    
    return vars.epsilon + dot(selfSum, selfSum) + neighborSum;
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateLambda(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        uint cell = cellContainingParticle[id.x];
        lambda[id.x] = (vars.restDensity - density[id.x]) / LambdaDenom(id.x);
    }
}

float AntiClusterTerm(float d2)
{
    return antiClusterCoefficient * WholePow(Poly2NKernel(vars.kernelDeg, vars.smoothingRadiusSqrd, d2), vars.antiClusterN);
}

void SearchCellForPositionDelta(uint p, uint cell, inout float2 sum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//otherwise gradient is zero
        {
            float2 d = position[p] - position[q];
            half d2 = dot(d, d);
            if (d2 < vars.smoothingRadiusSqrd)
            {
                sum += (lambda[p] + lambda[q] + AntiClusterTerm(d2)) * Poly2NKernelGradient(vars.kernelDeg, vars.smoothingRadiusSqrd, d2, d);
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculatePositionDelta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        float2 pos = position[id.x];
        int iMin = (int) clamp((pos.y - vars.smoothingRadius) / vars.cellSize, 0, config.height - 1);
        int iMax = (int) clamp((pos.y + vars.smoothingRadius) / vars.cellSize, 0, config.height - 1);
        int jMin = (int) clamp((pos.x - vars.smoothingRadius) / vars.cellSize, 0, config.width - 1);
        int jMax = (int) clamp((pos.x + vars.smoothingRadius) / vars.cellSize, 0, config.width - 1);
    
        float2 sum = 0;
        for (int i = iMin; i < iMax + 1; i++)
        {
            for (int j = jMin; j < jMax + 1; j++)
            {
                SearchCellForPositionDelta(id.x, Index(i, j), sum);
            }
        }
    
        particleBuffer[id.x] = 1 / vars.restDensity * sum;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void AddPositionDelta(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        position[id.x] += particleBuffer[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void StoreSolvedVelocity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        velocity[id.x] = vars.dtInverse * (position[id.x] - lastPosition[id.x]);
    }
}

void SearchCellForVorticityConfinement(uint p, uint cell, inout float2 viscSum, inout float2 vortSum)
{
    float rInverse = 1 / vars.smoothingRadius;
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        if (q != p)//otherwise contribution is zero
        {
            float2 positionDiff = position[p] - position[q];
            float d2 = dot(positionDiff, positionDiff);
            if (d2 < vars.smoothingRadiusSqrd)
            {
                float d = sqrt(d2);
                viscSum += (vars.smoothingRadius - d) * (velocity[q] - velocity[p]); //let's sample some viscosity while we're here
                
                float dInverse = 1 / d;
                float d3Inverse = dInverse / d2;
                
                if (!isnan(d3Inverse) && !isinf(d3Inverse))
                {
                    float2 velocityDiff = velocity[p] - velocity[q];
                    
                    float f = dInverse * rInverse * (velocityDiff.x * positionDiff.y - velocityDiff.y * positionDiff.x);
                    float fx = rInverse * (-positionDiff.x * d3Inverse * f - dInverse * velocityDiff.y);
                    float fy = rInverse * (-positionDiff.y * d3Inverse * f + dInverse * velocityDiff.x);
                    float2 F = abs(f) * normalize(float2(fy, -fx));
                    if (!isnan(F.x) && !isinf(F.x) && !isnan(F.y) && !isinf(F.y))
                    {
                        vortSum += F;
                    }
                    //using linear kernel A(1 - d / r)
                }
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateVorticityConfinementForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        float2 pos = position[id.x];
        int iMin = (int) clamp((pos.y - vars.smoothingRadius) / vars.cellSize, 0, config.height - 1);
        int iMax = (int) clamp((pos.y + vars.smoothingRadius) / vars.cellSize, 0, config.height - 1);
        int jMin = (int) clamp((pos.x - vars.smoothingRadius) / vars.cellSize, 0, config.width - 1);
        int jMax = (int) clamp((pos.x + vars.smoothingRadius) / vars.cellSize, 0, config.width - 1);
    
        float2 viscSum = 0;
        float2 vortSum = 0;
        for (int i = iMin; i < iMax + 1; i++)
        {
            for (int j = jMin; j < jMax + 1; j++)
            {
                SearchCellForVorticityConfinement(id.x, Index(i, j), viscSum, vortSum);
            }
        }
        
        particleBuffer[id.x] = vars.viscosity * viscSum - vars.vorticityConfinement / density[id.x] * vortSum;
    }
}


[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void IntegrateParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        velocity[id.x] += vars.dt * particleBuffer[id.x];//add viscosity and vorticity confinement forces
        RepelFromObstacles(id.x);
        position[id.x] = lastPosition[id.x] + vars.dt * velocity[id.x];
    }
}

void HandleWallCollisions(inout float2 position, inout float2 velocity)
{
    if (position.x < vars.cellSize)
    {
        float dx = position.x - vars.cellSize;
        position.x -= dx;
        if (velocity.x < 0)
        {
            velocity.x = -vars.collisionBounciness * velocity.x;
            //velocity.y = collisionBounciness * velocity.y;
        }
        velocity.x -= dx / vars.dt;
    }
    else if (position.x > vars.worldWidth - vars.cellSize)
    {
        float dx = position.x - vars.worldWidth + vars.cellSize;
        position.x -= dx;
        if (velocity.x > 0)
        {
            velocity.x = -vars.collisionBounciness * velocity.x;
            //velocity.y = collisionBounciness * velocity.y;
        }
        velocity.x -= dx / vars.dt;
    }

    if (position.y < vars.cellSize)
    {
        float dy = position.y - vars.cellSize;
        position.y -= dy;
        if (velocity.y < 0)
        {
            //velocity.x = collisionBounciness * velocity.x;
            velocity.y = -vars.collisionBounciness * velocity.y;
        }
        velocity.y -= dy / vars.dt;
    }
    else if (position.y > vars.worldHeight - vars.cellSize)
    {
        float dy = position.y - vars.worldHeight + vars.cellSize;
        position.y -= dy;
        if (velocity.y > 0)
        {
            //velocity.x = collisionBounciness * velocity.x;
            velocity.y = -vars.collisionBounciness * velocity.y;
        }
        velocity.y -= dy / vars.dt;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void HandleWallCollisions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        HandleWallCollisions(position[id.x], velocity[id.x]);
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ScrollNoise(uint3 id : SV_DispatchThreadID)
{
    if (id.x < config.numParticles)
    {
        noise[id.x].x += noise[id.x].y * vars.noiseScrollRate * vars.dt;
        if (noise[id.x].x > 1 || noise[id.x].x < 0)
        {
            noise[id.x].y *= -1;
        }
    }
}

void SearchCellForNoise(float2 pos, float2 v, float2 w, float2 sv, float2 sw, uint cell, float r2, inout float noiseSum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 d = pos - position[q];
        float2 a = dot(d, sv);
        float2 b = dot(d, sw);
        d = (a / vars.noiseStretch.x) * v + (b / vars.noiseStretch.y) * w; //stretch the noise wrt velocity!
        float d2 = dot(d, d);
        if (d2 < r2)
        {
            noiseSum += noise[q].x / density[q] * Poly2NKernel(vars.kernelDeg, r2, d2);
        }
    }
}

float SampleNoise(float2 pos, float r, float r2, out float2 v)
{
    int iMin = (int) clamp((pos.y - r) / vars.cellSize, 0, config.height - 1);
    int iMax = (int) clamp((pos.y + r) / vars.cellSize, 0, config.height - 1);
    int jMin = (int) clamp((pos.x - r) / vars.cellSize, 0, config.width - 1);
    int jMax = (int) clamp((pos.x + r) / vars.cellSize, 0, config.width - 1);
    
    v = SampleFloat2(velocity, pos, r, r2, vars.kernelDeg);
    float v2 = dot(v, v);
    float s = 1 / v2;
    if (isnan(s) || isinf(s))
    {
        return 0;
    }
    float2 w = float2(-v.y, v.x);
    float2 sv = s * v;
    float2 sw = float2(-sv.y, sv.x);
    float nSum = 0;
    
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellForNoise(pos, v, w, sv, sw, Index(i, j), r2, nSum);
        }
    }
    
    return (1 + min(vars.noiseVelocityInfluence * nSum * nSum * v2, vars.noiseVelocityInfluenceMax)) * nSum;
}

void SearchCellForFoaminess(float2 pos, float2 vel, uint cell, float r, float r2, inout float vSum)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 posDiff = pos - position[q];
        float d2 = dot(posDiff, posDiff);
        if (d2 < r2)
        {
            float d = sqrt(d2);
            float dInverse = 1 / d;
            if (!isnan(dInverse) && !isinf(dInverse))
            {
                    
                float2 velDiff = vel - velocity[q];
                float s = sqrt(dot(velDiff, velDiff));
                vSum += (s - dInverse * dot(velDiff, posDiff)) * Poly2NKernel(vars.kernelDeg, r2, d2) / density[q];
            }
        }
    }
}

float SampleFoaminess(float2 pos, float2 vel, float densitySample, float r, float r2)
{
    float a = clamp(vars.foamVelocityInfluence * dot(vel, vel) - vars.foamVelocityThreshold, 0, 1);
    if (a == 0)
    {
        return 0;
    }
    
    int iMin = (int) clamp((pos.y - r) / vars.cellSize, 0, config.height - 1);
    int iMax = (int) clamp((pos.y + r) / vars.cellSize, 0, config.height - 1);
    int jMin = (int) clamp((pos.x - r) / vars.cellSize, 0, config.width - 1);
    int jMax = (int) clamp((pos.x + r) / vars.cellSize, 0, config.width - 1);
    
    float vSum = 0;
    
    for (int i = iMin; i < iMax + 1; i++)
    {
        for (int j = jMin; j < jMax + 1; j++)
        {
            SearchCellForFoaminess(pos, vel, Index(i, j), r, r2, vSum);
        }
    }
    
    return a * vSum;
}

[numthreads(16, 16, 1)]
void UpdateDensityTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x < vars.texWidth && id.y < vars.texHeight)
    {
        //position of texel center on grid (world units)
        float2 pos = float2(vars.texelSizeX * (id.x + 0.5), vars.texelSizeY * (id.y + 0.5));
        
        float2 vel;
        float densitySample = SampleFloat(density, pos, vars.densityTexSmoothingRadius, vars.densityTexSmoothingRadiusSqrd, vars.kernelDeg);
        float noiseSample = SampleNoise(pos, vars.noiseSmoothingRadius, vars.noiseSmoothingRadiusSqrd, vel);
        float foaminess = SampleFoaminess(pos, vel, densitySample, vars.foamSmoothingRadius, vars.foamSmoothingRadiusSqrd);   
        
        uint2 k = uint2(id.x, id.y);
        densityTex[k] = half4(
            lerp(densityTex[k].x, densitySample, vars.timeBlur),
            lerp(densityTex[k].y, noiseSample, vars.noiseTimeBlur),
            lerp(densityTex[k].z, foaminess, vars.timeBlur),
            0
        );
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SpawnFoam(uint3 id :SV_DispatchThreadID)
{
    if (id.x < config.numParticles && foamParticleCounter[0] < config.numFoamParticles)
    {
        float2 pos = position[id.x];
        if (pos.x < 1.5 * vars.cellSize || pos.x > vars.worldWidth - 1.5 * vars.cellSize || pos.y < 1.5 * vars.cellSize)//don't know how else to get rid of the exaggerated foam at edges
        {
            return;
        }
        
        float2 vel = velocity[id.x];
        float dens = density[id.x];
        
        float foaminess = SampleFoaminess(pos, vel, dens, vars.foamParticleSmoothingRadius, vars.foamParticleSmoothingRadiusSqrd);
        
        uint seed = 73856093 * asuint(pos.x) ^ 19349669 * asuint(pos.y);
        
        int numToSpawn = /*dens **/ foaminess * vars.foamSpawnRate * vars.dt;
        
        if (numToSpawn > 0)
        {
            float spawnRadius = min(dens * vars.foamSpawnRadiusMultiplier, vars.foamSpawnRadiusMax);
            
            float2 v = vars.dt * vel;
            float2 w = float2(-v.y, v.x);
            //foamSpawnRadiusMax * d * v;
            //w = (-w.y, w.x);
            while (numToSpawn > 0)
            {
                uint index;
                InterlockedAdd(foamParticleCounter[0], 1, index);
                if (index < config.numFoamParticles)
                {
                    float a = RandomFloat01(seed);
                    float b = 2 * RandomFloat01(seed) - 1;
                    float2 c = b * spawnRadius * w;
                    foamParticle[index].position = pos + a * v + c;
                    foamParticle[index].velocity = velocity[id.x] + c;
                    foamParticle[index].life = lerp(vars.foamLifetimeMin, vars.foamLifetimeMax, RandomFloat01(seed));
                    foamParticle[index].colorNoise = RandomFloat01(seed);
                    foamParticle[index].sizeNoise = RandomFloat01(seed);
                    foamParticle[index].density = dens;
                    
                    numToSpawn--;
                }
                else
                {
                    break;
                }
            }
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void UpdateFoam(uint3 id : SV_DispatchThreadID)
{
    if (id.x < foamParticleCounter[0])
    {
        foamParticle[id.x].life -= vars.dt;
        if (!(foamParticle[id.x].life > 0))
        {
            return;
        }

        float2 pos = foamParticle[id.x].position;
        uint2 k = uint2(
            (uint) clamp(pos.x / vars.texelSizeX, 0, vars.texWidth - 1),
            (uint) clamp(pos.y / vars.texelSizeY, 0, vars.texHeight - 1)
        );
        
        float density = densityTex[k].x;
        
        foamParticle[id.x].density = density;
        
        if (density > vars.bubbleThreshold)//bubble particle
        {
            float2 v = SampleFloat2(velocity, pos, vars.foamParticleSmoothingRadius, vars.foamParticleSmoothingRadiusSqrd, vars.kernelDeg);
            foamParticle[id.x].velocity += -vars.dt * vars.bubbleBuoyancy * vars.gravity + vars.bubbleDrag * (v - foamParticle[id.x].velocity);
        }
        else if (density > vars.foamThreshold)//foam particle
        {
            foamParticle[id.x].velocity = SampleFloat2(velocity, pos, vars.foamSmoothingRadius, vars.foamSmoothingRadiusSqrd, vars.kernelDeg);
        }
        else//spray particle
        {
            foamParticle[id.x].velocity += vars.dt * (vars.gravity - vars.sprayDrag * foamParticle[id.x].velocity);
        }
        
        foamParticle[id.x].position += vars.dt * foamParticle[id.x].velocity;
        HandleWallCollisions(foamParticle[id.x].position, foamParticle[id.x].velocity);
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void TransferFoamSurvivorsToBuffer(uint3 id : SV_DispatchThreadID)
{
    if (id.x < foamParticleCounter[0] && foamParticle[id.x].life > 0)
    {
        int index;
        InterlockedAdd(foamParticleCounter[1], 1, index);
        foamParticleBuffer[index] = foamParticle[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void TransferFoamSurvivorsBack(uint3 id : SV_DispatchThreadID)
{
    if (id.x < foamParticleCounter[1])
    {
        foamParticle[id.x] = foamParticleBuffer[id.x];
    }
}

[numthreads(1, 1, 1)]
void CompleteFoamUpdate()
{
    foamParticleCounter[0] = foamParticleCounter[1];
    foamParticleCounter[1] = 0;
}