#pragma kernel ComputePredictedPositions
#pragma kernel CountParticles
#pragma kernel SetCellStarts
#pragma kernel SortParticlesByCell
#pragma kernel CalculateDensity
#pragma kernel AccumulateForces
#pragma kernel IntegrateParticles
#pragma kernel HandleWallCollisions

#include "./SPHFunctions.hlsl"

static const int NUM_THREADS_PER_GROUP = 256;
static const float COS45 = rsqrt(2);


//CONFIGURATION

const uint width;
const uint height;
const uint numCells;
const uint numParticles;


//SIM SETTINGS

uniform float dt;
uniform float cellSize;
uniform float worldWidth;
uniform float worldHeight;
uniform float smoothingRadius;
uniform float smoothingRadiusSqrd;
uniform float2 gravity;
uniform float stiffnessCoefficient;
uniform float nearStiffnessCoefficient;
uniform float restDensity;
uniform float viscosity;
uniform float collisionBounciness;
uniform float obstacleRepulsion;
uniform uint numObstacles = 1;


//SIM DATA

RWStructuredBuffer<float> particleDensity;
RWStructuredBuffer<float> nearDensity;
RWStructuredBuffer<float2> particleAcceleration;
RWStructuredBuffer<float2> particleVelocity;
RWStructuredBuffer<float2> particlePosition;
RWStructuredBuffer<float2> predictedPosition;

//particle sorting
RWStructuredBuffer<uint> cellContainingParticle;
RWStructuredBuffer<uint> particlesByCell;
RWStructuredBuffer<uint> cellStart;
RWStructuredBuffer<uint> cellParticleCount;

StructuredBuffer<float4> obstacleData;

#define Index(i, j) i * width + j

void RepelFromObstacles(uint p)
{
    for (uint k = 0; k < numObstacles; k++)
    {
        float4 o = obstacleData[k];
        float2 localPos = float2((particlePosition[p].x - o.x) / o.z, (particlePosition[p].y - o.y) / o.w); //make an ellipse out of the collider's bounding box
        float s2 = localPos.x * localPos.x + localPos.y * localPos.y;
        if (s2 < 1)
        {
            float sInverse = rsqrt(s2);
            float2 dir = isnan(sInverse) || isinf(sInverse) ? float2(0, 1) : sInverse * localPos;
            particleVelocity[p] += dt * (1 - s2) * (obstacleRepulsion - dot(particleVelocity[p], dir)) * dir;
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ComputePredictedPositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        particleVelocity[id.x] += dt * gravity;
        RepelFromObstacles(id.x);
        predictedPosition[id.x] = particlePosition[id.x] + dt * particleVelocity[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void IntegrateParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        particleVelocity[id.x] += dt * particleAcceleration[id.x];
        particlePosition[id.x] += dt * particleVelocity[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void HandleWallCollisions(uint3 id : SV_DispatchThreadID)
{
    if (!(id.x < numParticles))
    {
        return;
    }
    
    if (particlePosition[id.x].x < cellSize)
    {
        float dx = particlePosition[id.x].x - cellSize;
        particlePosition[id.x].x -= dx;
        if (particleVelocity[id.x].x < 0)
        {
            particleVelocity[id.x].x = -collisionBounciness * particleVelocity[id.x].x;
            //particleVelocity[id.x].y = collisionBounciness * particleVelocity[id.x].y;
        }
        particleVelocity[id.x].x -= dx / dt;
    }
    else if (particlePosition[id.x].x > worldWidth - cellSize)
    {
        float dx = particlePosition[id.x].x - worldWidth + cellSize;
        particlePosition[id.x].x -= dx;
        if (particleVelocity[id.x].x > 0)
        {
            particleVelocity[id.x].x = -collisionBounciness * particleVelocity[id.x].x;
            //particleVelocity[id.x].y = collisionBounciness * particleVelocity[id.x].y;
        }
        particleVelocity[id.x].x -= dx / dt;
    }

    if (particlePosition[id.x].y < cellSize)
    {
        float dy = particlePosition[id.x].y - cellSize;
        particlePosition[id.x].y -= dy;
        if (particleVelocity[id.x].y < 0)
        {
            //particleVelocity[id.x].x = collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = -collisionBounciness * particleVelocity[id.x].y;
        }
        particleVelocity[id.x].y -= dy / dt;
    }
    else if (particlePosition[id.x].y > worldHeight - cellSize)
    {
        float dy = particlePosition[id.x].y - worldHeight + cellSize;
        particlePosition[id.x].y -= dy;
        if (particleVelocity[id.x].y > 0)
        {
            //particleVelocity[id.x].x = collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = -collisionBounciness * particleVelocity[id.x].y;
        }
        particleVelocity[id.x].y -= dy / dt;
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CountParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float w = predictedPosition[id.x].x / cellSize;
        float h = predictedPosition[id.x].y / cellSize;
        uint i = (uint) clamp(h, 0, height - 1);
        uint j = (uint) clamp(w, 0, width - 1);
        uint c = Index(i, j);
        cellContainingParticle[id.x] = c;
        InterlockedAdd(cellParticleCount[c], 1);
    }
}

//not parallelized
[numthreads(1, 1, 1)]
void SetCellStarts(uint3 id : SV_DispatchThreadID)
{
    cellStart[0] = 0;
    for (uint k = 1; k < numCells + 1; k++)
    {
        cellStart[k] = cellStart[k - 1] + cellParticleCount[k - 1];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SortParticlesByCell(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint d;
        InterlockedAdd(cellParticleCount[c], -1, d);
        uint l = cellStart[c] + d - 1;
        particlesByCell[l] = id.x;
    }
}

void SearchCellDensity(uint p, uint cell)
{
    float sum = 0;
    float nearSum = 0;
    
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float d2 = pow(predictedPosition[q].x - predictedPosition[p].x, 2) + pow(predictedPosition[q].y - predictedPosition[p].y, 2);
        if (d2 < smoothingRadiusSqrd)
        {
            float d = sqrt(d2);
            sum += SimpleQuadraticKernel(smoothingRadius, smoothingRadiusSqrd, d);
            nearSum += SimpleCubicKernel(smoothingRadius, smoothingRadiusSqrd, d);
        }
    }
    
    particleDensity[p] += sum;
    nearDensity[p] += nearSum;
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint i = c / width;
        uint j = c % width;
        float cellX = clamp(predictedPosition[id.x].x - j * cellSize, 0, cellSize);
        float cellY = clamp(predictedPosition[id.x].y - i * cellSize, 0, cellSize);
        float max = cellSize - smoothingRadius;
        
        particleDensity[id.x] = 0;
        nearDensity[id.x] = 0;
        
        //search middle row
        SearchCellDensity(id.x, c);
        
        if (j > 0 && cellX < smoothingRadius)
        {
            SearchCellDensity(id.x, c - 1);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellDensity(id.x, c + 1);
        }
        
        //search upper row
        if (i < height - 1 && cellY > max)
        {
            SearchCellDensity(id.x, c + width);
            
            if (j > 0 && cellX < smoothingRadius)
            {
                SearchCellDensity(id.x, c + width - 1);
            }
            if (j < width - 1 && cellX > max)
            {
                SearchCellDensity(id.x, c + width + 1);
            }
        }
        
        //search bottom row
        if (i > 0 && cellY < smoothingRadius)
        {
            SearchCellDensity(id.x, c - width);
            
            if (j > 0 && cellX < smoothingRadius)
            {
                SearchCellDensity(id.x, c - width - 1);
            }
            if (j < width - 1 && cellX > max)
            {
                SearchCellDensity(id.x, c - width + 1);
            }
        }
    }
}

void SearchCellForces(uint p, uint cell)
{
    float2 pressureSum = 0;
    float2 nearPressureSum = 0;
    float2 viscositySum = 0;
    
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 displacement = float2(predictedPosition[p].x - predictedPosition[q].x, predictedPosition[p].y - predictedPosition[q].y);
        float d2 = displacement.x * displacement.x + displacement.y * displacement.y;
        if (d2 < smoothingRadiusSqrd)
        {
            float d = sqrt(d2);
            float2 u = displacement / d;
            if (!isnan(u.x) && !isnan(u.y) && !isinf(u.x) && !isinf(u.y))
            {
                float avgDensity = 0.5 * (particleDensity[p] + particleDensity[q]);
                float avgNearDensity = 0.5 * (nearDensity[p] + nearDensity[q]);
                pressureSum += (avgDensity - restDensity) / particleDensity[q] * SimpleLinearKernel(smoothingRadius, smoothingRadiusSqrd, d) * u;
                nearPressureSum += avgNearDensity / nearDensity[q] * SimpleQuadraticKernel(smoothingRadius, smoothingRadiusSqrd, d) * u;
            }
            
            viscositySum += viscosity * SimpleLinearKernel(smoothingRadius, smoothingRadiusSqrd, d) / particleDensity[q] * (particleVelocity[q] - particleVelocity[p]);
        }
    }
    
    //pressures added because their weight functions are already missing a negative
    particleAcceleration[p] += (1 / particleDensity[p]) * (stiffnessCoefficient * pressureSum + nearStiffnessCoefficient * nearPressureSum + viscositySum);
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void AccumulateForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        particleAcceleration[id.x] = 0;
        
        uint c = cellContainingParticle[id.x];
        uint i = c / width;
        uint j = c % width;
        float cellX = clamp(predictedPosition[id.x].x - j * cellSize, 0, cellSize);
        float cellY = clamp(predictedPosition[id.x].y - i * cellSize, 0, cellSize);
        float max = cellSize - smoothingRadius;
        
        //search middle row
        SearchCellForces(id.x, c);
        
        if (j > 0 && cellX < smoothingRadius)
        {
            SearchCellForces(id.x, c - 1);
        }
        if (j < width - 1 && cellX > max)
        {
            SearchCellForces(id.x, c + 1);
        }
        
        //search upper row
        if (i < height - 1 && cellY > max)
        {
            SearchCellForces(id.x, c + width);
            
            if (j > 0 && cellX < smoothingRadius)
            {
                SearchCellForces(id.x, c + width - 1);
            }
            if (j < width - 1 && cellX > max)
            {
                SearchCellForces(id.x, c + width + 1);
            }
        }
        
        //search bottom row
        if (i > 0 && cellY < smoothingRadius)
        {
            SearchCellForces(id.x, c - width);
            
            if (j > 0 && cellX < smoothingRadius)
            {
                SearchCellForces(id.x, c - width - 1);
            }
            if (j < width - 1 && cellX > max)
            {
                SearchCellForces(id.x, c - width + 1);
            }
        }
    }
}