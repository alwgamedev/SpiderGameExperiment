#pragma kernel ComputePredictedPositions
#pragma kernel CountParticles
#pragma kernel SetCellStarts
#pragma kernel SortParticlesByCell
#pragma kernel CalculateDensity
#pragma kernel AccumulateForces
#pragma kernel IntegrateParticles
#pragma kernel HandleWallCollisions

#include "./SPHFunctions.hlsl"

static const int NUM_THREADS_PER_GROUP = 256;
static const float COS45 = rsqrt(2);


//CONFIGURATION

const uint width;
const uint height;
const uint numCells;
const uint numParticles;


//SIM SETTINGS

uniform float dt;
uniform float cellSize;
uniform float worldWidth;
uniform float worldHeight;
uniform float smoothingRadius;
uniform float smoothingRadiusSqrd;
uniform float2 gravity;
uniform float igConstant;
uniform float restDensity;
uniform float viscosity;
uniform float particleMass;
uniform float collisionBounciness;
uniform float obstacleRepulsion;
uniform uint numObstacles = 1;


//SIM DATA

RWStructuredBuffer<float> particleDensity;
RWStructuredBuffer<float2> particleAcceleration;
RWStructuredBuffer<float2> particleVelocity;
RWStructuredBuffer<float2> particlePosition;
RWStructuredBuffer<float2> predictedPosition;

//particle sorting
RWStructuredBuffer<uint> cellContainingParticle;
RWStructuredBuffer<uint> particlesByCell;
RWStructuredBuffer<uint> cellStart;
RWStructuredBuffer<uint> cellParticleCount;

StructuredBuffer<float4> obstacleData;

#define Index(i, j) i * width + j
#define pressure(i) igConstant * (particleDensity[i] - restDensity)

void ApplyExternalForces(uint p)
{
    for (uint k = 0; k < numObstacles; k++)
    {
        float4 o = obstacleData[k];
        float2 localPos = float2((particlePosition[p].x - o.x) / o.z, (particlePosition[p].y - o.y) / o.w); //make an ellipse out of the collider's bounding box
        float s2 = localPos.x * localPos.x + localPos.y * localPos.y;
        if (s2 < 1)
        {
            float sInverse = rsqrt(s2);
            float2 dir = isnan(sInverse) || isinf(sInverse) ? float2(0, 1) : sInverse * localPos;
            particleVelocity[p] += (1 - s2) * (dt * obstacleRepulsion - dot(particleVelocity[p], dir)) * dir;
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void ComputePredictedPositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        particleVelocity[id.x] += dt * gravity;
        ApplyExternalForces(id.x);
        predictedPosition[id.x] = particlePosition[id.x] + dt * particleVelocity[id.x];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void IntegrateParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        particleVelocity[id.x] += dt * particleAcceleration[id.x];
        particlePosition[id.x] += dt * particleVelocity[id.x];
    }
}

//could switch this to being an external force
[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void HandleWallCollisions(uint3 id : SV_DispatchThreadID)
{
    if (!(id.x < numParticles))
    {
        return;
    }
    
    if (particlePosition[id.x].x < cellSize)
    {
        particlePosition[id.x].x = cellSize;
        if (particleVelocity[id.x].x < 0)
        {
            particleVelocity[id.x].x = -collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = collisionBounciness * particleVelocity[id.x].y;
        }
    }
    else if (particlePosition[id.x].x > worldWidth - cellSize)
    {
        particlePosition[id.x].x = worldWidth - cellSize;
        if (particleVelocity[id.x].x > 0)
        {
            particleVelocity[id.x].x = -collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = collisionBounciness * particleVelocity[id.x].y;
        }
    }

    if (particlePosition[id.x].y < cellSize)
    {
        particlePosition[id.x].y = cellSize;
        if (particleVelocity[id.x].y < 0)
        {
            particleVelocity[id.x].x = collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = -collisionBounciness * particleVelocity[id.x].y;
        }
    }
    else if (particlePosition[id.x].y > worldHeight - cellSize)
    {
        particlePosition[id.x].y = worldHeight - cellSize;
        if (particleVelocity[id.x].y > 0)
        {
            particleVelocity[id.x].x = collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = -collisionBounciness * particleVelocity[id.x].y;
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CountParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float w = predictedPosition[id.x].x / cellSize;
        float h = predictedPosition[id.x].y / cellSize;
        uint i = (uint) clamp(h, 0, height - 1);
        uint j = (uint) clamp(w, 0, width - 1);
        uint c = Index(i, j);
        cellContainingParticle[id.x] = c;
        InterlockedAdd(cellParticleCount[c], 1);
    }
}

//not parallelized
[numthreads(1, 1, 1)]
void SetCellStarts(uint3 id : SV_DispatchThreadID)
{
    cellStart[0] = 0;
    for (uint k = 1; k < numCells + 1; k++)
    {
        cellStart[k] = cellStart[k - 1] + cellParticleCount[k - 1];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SortParticlesByCell(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint d;
        InterlockedAdd(cellParticleCount[c], -1, d);
        uint l = cellStart[c] + d - 1;
        particlesByCell[l] = id.x;
    }
}

void SearchCellDensity(uint p, uint cell)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float d2 = pow(predictedPosition[q].x - predictedPosition[p].x, 2) + pow(predictedPosition[q].y - predictedPosition[p].y, 2);
        if (d2 < smoothingRadiusSqrd)
        {
            particleDensity[p] += particleMass * DensityWt(smoothingRadiusSqrd, d2);
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint i = c / width;
        uint j = c % width;
        
        particleDensity[id.x] = 0;
        
        //search middle row
        SearchCellDensity(id.x, c);
        
        if (j > 0)
        {
            SearchCellDensity(id.x, c - 1);
        }
        if (j < width - 1)
        {
            SearchCellDensity(id.x, c + 1);
        }
        
        //search upper row
        if (i < height - 1)
        {
            SearchCellDensity(id.x, c + width);
            
            if (j > 0)
            {
                SearchCellDensity(id.x, c + width - 1);
            }
            if (j < width - 1)
            {
                SearchCellDensity(id.x, c + width + 1);
            }
        }
        
        //search bottom row
        if (i > 0)
        {
            SearchCellDensity(id.x, c - width);
            
            if (j > 0)
            {
                SearchCellDensity(id.x, c - width - 1);
            }
            if (j < width - 1)
            {
                SearchCellDensity(id.x, c - width + 1);
            }
        }
    }
}

void SearchCellForces(uint p, uint cell)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 displacement = float2(predictedPosition[p].x - predictedPosition[q].x, predictedPosition[p].y - predictedPosition[q].y);
        float d2 = displacement.x * displacement.x + displacement.y * displacement.y;
        if (d2 < smoothingRadiusSqrd)
        {
            float d = sqrt(d2);
            float pW = PressureWt(smoothingRadius, d);
            if (!isinf(pW))
            {
                particleAcceleration[p] -= ((pressure(p) + pressure(q)) / (2 * particleDensity[q])) * PressureWt(smoothingRadius, d) * displacement;
            }
            particleAcceleration[p] += (viscosity * ViscosityWt(smoothingRadius, d) / particleDensity[q]) * (particleVelocity[q] - particleVelocity[p]);
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]

    void AccumulateForces
    (
    uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        particleAcceleration[id.x] = 0;
        
        uint c = cellContainingParticle[id.x];
        uint i = c / width;
        uint j = c % width;
        
        //search middle row
        SearchCellForces(id.x, c);
        
        if (j > 0)
        {
            SearchCellForces(id.x, c - 1);
        }
        if (j < width - 1)
        {
            SearchCellForces(id.x, c + 1);
        }
        
        //search upper row
        if (i < height - 1)
        {
            SearchCellForces(id.x, c + width);
            
            if (j > 0)
            {
                SearchCellForces(id.x, c + width - 1);
            }
            if (j < width - 1)
            {
                SearchCellForces(id.x, c + width + 1);
            }
        }
        
        //search bottom row
        if (i > 0)
        {
            SearchCellForces(id.x, c - width);
            
            if (j > 0)
            {
                SearchCellForces(id.x, c - width - 1);
            }
            if (j < width - 1)
            {
                SearchCellForces(id.x, c - width + 1);
            }
        }
    }
}