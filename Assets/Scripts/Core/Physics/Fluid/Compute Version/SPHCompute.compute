#pragma kernel IntegrateParticles
#pragma kernel HandleWallCollisions
#pragma kernel CountParticles
#pragma kernel SetCellStarts
#pragma kernel SortParticlesByCell
#pragma kernel CalculateDensity
#pragma kernel AccumulateForces

#include "./SPHFunctions.hlsl"

static const int NUM_THREADS_PER_GROUP = 256;
static const float COS45 = rsqrt(2);


//CONFIGURATION

const uint width;
const uint height;
const uint numCells;
const uint numParticles;


//SIM SETTINGS

uniform float dt;
uniform float cellSize;
uniform float worldWidth;
uniform float worldHeight;
uniform float smoothingRadius;
uniform float smoothingRadiusSqrd;
uniform float gravity;
uniform float igConstant;
uniform float restDensity;
uniform float viscosity;
//uniform float particleRadius;
uniform float particleMass;
uniform float collisionBounciness;


//SIM DATA

RWStructuredBuffer<float> particleDensity;
RWStructuredBuffer<float2> particleAcceleration;
RWStructuredBuffer<float2> particleVelocity;
RWStructuredBuffer<float2> particlePosition;

//particle sorting
RWStructuredBuffer<uint> cellContainingParticle;
RWStructuredBuffer<uint> particlesByCell;
RWStructuredBuffer<uint> cellStart;
RWStructuredBuffer<uint> cellParticleCount;

#define Index(i, j) i * width + j
#define pressure(i) igConstant * (particleDensity[i] - restDensity)

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void IntegrateParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        particleVelocity[id.x] += dt * particleAcceleration[id.x];
        particlePosition[id.x] += dt * particleVelocity[id.x];
    }
}

//could switch this to being an external force
[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void HandleWallCollisions(uint3 id : SV_DispatchThreadID)
{
    if (!(id.x < numParticles))
    {
        return;
    }
    
    if (particlePosition[id.x].x < cellSize)
    {
        particlePosition[id.x].x = cellSize;
        if (particleVelocity[id.x].x < 0)
        {
            particleVelocity[id.x].x = -collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = collisionBounciness * particleVelocity[id.x].y;
        }
    }
    else if (particlePosition[id.x].x > worldWidth - cellSize)
    {
        particlePosition[id.x].x = worldWidth - cellSize;
        if (particleVelocity[id.x].x > 0)
        {
            particleVelocity[id.x].x = -collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = collisionBounciness * particleVelocity[id.x].y;
        }
    }

    if (particlePosition[id.x].y < cellSize)
    {
        particlePosition[id.x].y = cellSize;
        if (particleVelocity[id.x].y < 0)
        {
            particleVelocity[id.x].x = collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = -collisionBounciness * particleVelocity[id.x].y;
        }
    }
    else if (particlePosition[id.x].y > worldHeight - cellSize)
    {
        particlePosition[id.x].y = worldHeight - cellSize;
        if (particleVelocity[id.x].y > 0)
        {
            particleVelocity[id.x].x = collisionBounciness * particleVelocity[id.x].x;
            particleVelocity[id.x].y = -collisionBounciness * particleVelocity[id.x].y;
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CountParticles(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        float w = particlePosition[id.x].x / cellSize;
        float h = particlePosition[id.x].y / cellSize;
        uint i = (uint) clamp(h, 0, height - 1);
        uint j = (uint) clamp(w, 0, width - 1);
        uint c = Index(i, j);
        cellContainingParticle[id.x] = c;
        InterlockedAdd(cellParticleCount[c], 1);
    }
}

//not parallelized
[numthreads(1, 1, 1)]
void SetCellStarts(uint3 id : SV_DispatchThreadID)
{
    cellStart[0] = 0;
    for (uint k = 1; k < numCells + 1; k++)
    {
        cellStart[k] = cellStart[k - 1] + cellParticleCount[k - 1];
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void SortParticlesByCell(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint d;
        InterlockedAdd(cellParticleCount[c], -1, d);
        uint l = cellStart[c] + d - 1;
        particlesByCell[l] = id.x;
    }
}

void SearchCellDensity(uint p, uint cell)
{
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float d2 = pow(particlePosition[q].x - particlePosition[p].x, 2) + pow(particlePosition[q].y - particlePosition[p].y, 2);
        if (d2 < smoothingRadiusSqrd)
        {
            particleDensity[p] += particleMass * DensityWt(smoothingRadiusSqrd, d2);
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]
void CalculateDensity(uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        uint c = cellContainingParticle[id.x];
        uint i = c / width;
        uint j = c % width;
        float cellX = particlePosition[id.x].x - j * width;
        float cellY = particlePosition[id.x].x - i * height;
        
        //float upperThreshold = cellSize - smoothingRadius;
        
        particleDensity[id.x] = 0;
        
        //search middle row
        SearchCellDensity(id.x, c);
        
        if (j > 0 /*&& cellY < smoothingRadius*/)
        {
            SearchCellDensity(id.x, c - 1);
        }
        if (j < width - 1 /*&& cellY > upperThreshold*/)
        {
            SearchCellDensity(id.x, c + 1);
        }
        
        //search upper row
        if (i < height - 1 /*&& cellY > cellSize - smoothingRadius*/)
        {
            SearchCellDensity(id.x, c + width);
            
            if (j > 0 /*&& cellY < smoothingRadius*/)
            {
                SearchCellDensity(id.x, c + width - 1);
            }
            if (j < width - 1 /*&& cellY > upperThreshold*/)
            {
                SearchCellDensity(id.x, c + width + 1);
            }
        }
        
        //search bottom row
        if (i > 0 /*&& cellY < smoothingRadius*/)
        {
            SearchCellDensity(id.x, c - width);
            
            if (j > 0 /*&& cellY < smoothingRadius*/)
            {
                SearchCellDensity(id.x, c - width - 1);
            }
            if (j < width - 1 /*&& cellY > upperThreshold*/)
            {
                SearchCellDensity(id.x, c - width + 1);
            }
        }
    }
}

void SearchCellForces(uint p, uint cell)
{
    float v = particleMass / particleDensity[p];
    for (uint k = cellStart[cell]; k < cellStart[cell + 1]; k++)
    {
        uint q = particlesByCell[k];
        float2 displacement = float2(particlePosition[q].x - particlePosition[p].x, particlePosition[q].y - particlePosition[p].y);
        float d2 = displacement.x * displacement.x + displacement.y * displacement.y;
        if (d2 < smoothingRadiusSqrd)
        {
            float d = sqrt(d2);
            float pW = PressureWt(smoothingRadius, d);
            if (!isinf(pW))
            {
                particleAcceleration[p] -= ((pressure(p) + pressure(q)) / (2 * particleDensity[q])) * pW * displacement;
            }
            particleAcceleration[p] += (viscosity * ViscosityWt(smoothingRadius, d) / particleDensity[q]) * (particleVelocity[q] - particleVelocity[p]);
        }
    }
}

[numthreads(NUM_THREADS_PER_GROUP, 1, 1)]

    void AccumulateForces
    (
    uint3 id : SV_DispatchThreadID)
{
    if (id.x < numParticles)
    {
        particleAcceleration[id.x].x = 0;
        particleAcceleration[id.x].y = gravity;
        
        uint c = cellContainingParticle[id.x];
        uint i = c / width;
        uint j = c % width;
        float cellX = particlePosition[id.x].x - j * cellSize;
        float cellY = particlePosition[id.x].y - i * cellSize;
        
        //search middle row
        SearchCellForces(id.x, c);
        
        if (j > 0 /*&& cellY < smoothingRadius*/)
        {
            SearchCellForces(id.x, c - 1);
        }
        if (j < width - 1 /*&& cellY > upperThreshold*/)
        {
            SearchCellForces(id.x, c + 1);
        }
        
        //search upper row
        if (i < height - 1 /*&& cellY > cellSize - smoothingRadius*/)
        {
            SearchCellForces(id.x, c + width);
            
            if (j > 0 /*&& cellY < smoothingRadius*/)
            {
                SearchCellForces(id.x, c + width - 1);
            }
            if (j < width - 1 /*&& cellY > upperThreshold*/)
            {
                SearchCellForces(id.x, c + width + 1);
            }
        }
        
        //search bottom row
        if (i > 0 /*&& cellY < smoothingRadius*/)
        {
            SearchCellForces(id.x, c - width);
            
            if (j > 0 /*&& cellY < smoothingRadius*/)
            {
                SearchCellForces(id.x, c - width - 1);
            }
            if (j < width - 1 /*&& cellY > upperThreshold*/)
            {
                SearchCellForces(id.x, c - width + 1);
            }
        }
    }
}